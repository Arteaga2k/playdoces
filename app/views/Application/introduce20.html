<!DOCTYPE html>
<html>
	<head>
		<title>Introducing Play 2.0</title>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
		<link rel="stylesheet" href="/public/2.0/stylesheets/styles.css" media="screen" charset="utf-8" />
		<script src="http://code.jquery.com/jquery-1.4.2.min.js" type="text/javascript" charset="utf-8"></script>
		<script src="/public/2.0/javascript/script.js" type="text/javascript" charset="utf-8"></script>
	</head>
	<body>
		<div id="home"></div>
		<header id="top">
			<a href="#home" id="logo"><img src="/public/2.0/images/mini-logo.png" alt="Play framework" width="83"/></a>
			<ul id="menu">
				<li><a href="#changes">Play 2.0 の紹介</a></li>
				<li><a href="#features">進捗確認</a></li>

				<li><a href="#faq">よくある質問</a></li>
				<li><a href="#share">共有</a></li>
			</ul>
			<span id="marker"></span>
		</header>
		<div id="announcement">
			<div id="description">
				<h1>Play 2.0 への取り組み</h1>

				<p>前に進むときが来ました！私たちは Java と Scala の完全なサポートと共に、新しいビルドシステムと驚くべき非同期機能を統合しながら、Play framework の次のメジャーバージョンに取り組んでいます。</p>
				<p>Play 2.0 は、まだまだ開発が進められている最中であり、API の変更も行われることになりますが、もうすでにプレビューバージョンをご覧いただくことが可能です。</p>
				<dl id="download">
					<dt><a href="http://download.playframework.org/releases/play-2.0-preview.zip">Play-2.0-preview ダウンロード</a></dt>
					<dd><a href="http://github.com/playframework/play20">Github でソースコードを確認する</a></dd>
				</dl>
			</div>

			<div id="history" class="v1">
				<div id="hplay">Play! framework</div>
				<div id="hjava">Java</div>
				<div id="hscala">Scala</div>
				<div id="hjsp">JSP</div>
				<div id="hservlet">Servlet</div>

				<div id="hgroovy">Groovy</div>
				<div id="hpython">Python</div>
				<div id="hasync">Async I/O</div>
				<div id="hsbt">sbt</div>
				<div id="hakka">Akka</div>
				<div id="hdeps">Ivy</div>

				<div id="hsocket">WebSockets</div>
				<div id="htemplates">Templates</div>
				<ul id="historyMenu">
					<li id="va">0.x</li>
					<li id="vb">1.0</li>
					<li id="v1" class="active">1.2</li>

					<li id="v2">2.0</li>
				</ul>
			</div>
		</div>
		<section id="wrapper">

			<article id="changes">
				<header>
					<h1>Play 2.0 の紹介</h1>

					<p>Guillaume Bort, Play プロジェクト開発者リーダー</p>
				</header>
				<div class="cols">
					<p>2007年以来、私たちはJavaでのWebアプリケーションの開発を容易なものにしようとしてきました。Playは、Zenexityにおける内部的なプロジェクトとしてスタートし、私たちのWebプロジェクトの進め方に強く影響されてきました。つまり、開発者の生産性に焦点を当て、Webのアーキテクチャを尊重し、初めからパッケージングに斬新なやり方を採用してきたのですーそうすることが理にかなっている場合には、いわゆるJEEのベストプラクティスをも破ってきました。</p>
					<p>2009年に、私たちはこれらのアイデアを、オープンソースプロジェクトとしてコミュニティと共有することを決断しました。即座に返されたフィードバックは極めてポジティブなものであり、このプロジェクトは大きな関心を引きつけました。今日ー2年間の活発な開発を経てーPlayにはいくつかのバージョンができ、3,000人の参加者からなる活発なコミュニティが存在し、世界中で実際に使われているアプリケーションの数は増え続けています。</p>
					<p>世界中に対してプロジェクトを解放するということは、確かにより多くのフィードバックを得られるということではありますが、それはまた、新たなユースケースに出会ってそこから学ぶことや、新たな機能が必要になることや、 元々の設計や前提の下では考慮されていなかったバグが明らかになることでもあります。オープンソースプロジェクトとしてPlayに取り組んできた2年の間に、私たちはこういったすべての問題を修復し、加えて広範囲なシナリオをサポートするための新たな機能を統合してきました。Playのプロジェクトが成長するにつれて、私たちはPlayのコミュニティと、私たち自身の経験から学びましたーPlayは、どんどん複雑で、多様なプロジェクトで使われるようになってきたのです。</p>
					<p>一方、技術とWebの進化の歩みはとどまることを知りません。Webは、あらゆるアプリケーションの中心となりました。HTML、CSS、JavaScriptの技術は、急速に発展してきましたーサーバーサイドのフレームワークがついていくことはほとんど不可能なほどです。Webのアーキテクチャは、総体として、リアルタイム処理の方向へ急速に向かっており、今日のプロジェクト群に求められるようになった事項からは、データストア技術としてSQLを唯一のものとするわけにはいかなくなっていることが分かります。プログラミング言語のレベルにおいては、私たちは、一般的になってきたScalaを含むいくつかのJVM言語に関連する、後々まで記憶されるような変化の目撃者となりました。</p>

					<p><strong>以上が、いまこそ次へ進むときだと私たちが判断し、Playの新たなメジャーバージョンについて考えている理由です。Play 2.0へようこそ！</strong></p>
				</div>

				<div id="wholeAnnouncement">

				    <h2>Java及びScalaのネイティブサポート</h2>
    				<div class="cols">
    					<p>Play 1.1から、Playのアプリケーションを書くのにプログラミング言語Scalaを使用する可能性を、私たちは探り始めました。この作業は、まずフレームワークそのものに影響を与えることなく、自由に試せるような外部モジュールとして導入されました。</p>

    					<p>Scalaを適切にJavaベースのフレームワークに統合することは容易なことではありません。Scalaが持つJavaとの互換性を考慮すれば、単純にScalaのシンタックスをJavaのシンタックスの代わりに使う形で、まず単純に素早く統合してしまうことは可能です。しかしこれは間違いなく、Scalaを利用する上で最適な方法ではありません。Scalaは、真のオブジェクト指向と関数型プログラミングを混合したものです。Scalaの本当のパワーを解放するには、PlayのフレームワークのAPIの多くを再検討しなければなりません。いくつかのバージョンを経て、私たちはクリーンなScalaモジュールを作り上げることができました。これは、Playの機能の多くを、Scala的なやり方でScalaから利用できるものです。</p>
    					<p>今では、私たちは個別のモジュールとしてScalaをサポートするやり方の限界点に到達しています。私たちがPlay 1.xで行った、初期の設計における選択は、JavaのリフレクションAPIとバイトコードの操作に強く依存しており、Playの内部の重要な部分のいくつかについて完全に再検討し直さなければ、これ以上の進歩は難しくなっていました。一方で、私たちはScalaモジュールのために、新たな型安全テンプレートエンジンや、まったく新しいSQLアクセスコンポーネントであるAnormといった、複数の素晴らしいコンポーネントを作成していました。そこで私たちは、Scalaの持つパワーをPlayで完全に解放するために、Scalaのサポートを個別のモジュールから、Play 2.0のコアへ移すことを決断しました。このPlay 2.0のコアは、初めからプログラミング言語としてScalaをネイティブにサポートするよう設計されることになります。</p>
    					<p>一方で、Javaに対するサポートがPlay 2.0から弱くなることはまったくありません。むしろ、完全にその反対なのです。Play 2.0のビルドは、Javaの開発者に対し、開発の体験を拡張する機会を提供します。このプロジェクトにおける私たちの経験から、私たちは何を達成し、どんな過ちを避けなければならないのか、はっきりとした考えを持っています。</p>
    				</div>

    				<h2>強力なビルドシステム</h2>

    				<div class="cols">
    					<p>私たちは初めから、Playのアプリケーションの実行、コンパイル、デプロイについて、新鮮な方法を選択してきました。当初、私たちの採った方法は、難解な設計に見えたかも知れませんーしかし、標準的なServlet APIの代わりに非同期HTTP APIを提供し、ライブコンパイルと開発中のソースコードのリロードによって短いフィードバックサイクルを提供し、斬新なパッケージングのアプローチを推進することは、極めて重要なことだったのです。その結果として、Playが標準的なJEEの規約に従うことは難しくなりました。</p>
    					<p>今日では、コンテナレスデプロイメントの概念は、Javaの世界において非常に広く受け入れられるようになってきました。この設計上の選択によって、Play frameworkはHerokuのようなプラットフォームにおいてネイティブに動作できるようになりました。私たちは、Herokuによって紹介されたモデルは、エラスティックなPaaSプラットフォームにおけるJavaアプリケーションのデプロイメントの未来だと考えています。</p>
    					<p>一方で、既存のJavaのビルドシステムは、この新しいアプローチをサポートするには、柔軟性が不足していました。私たちは、Playのアプリケーションを実行し、デプロイするための単純明快なツールを提供したいと考えていたことから、Play 1.xでは ビルドとデプロイメントのタスクのすべてを処理するために、Pythonスクリプトの集合体を作り上げました。</p>
    					<p>しかし、ビルドのプロセスのカスタマイズや、企業内の既存のビルドシステムとの統合が求められる、よりエンタープライズ規模のプロジェクトでPlayを使っている開発者の方々は、少々困っていました。私たちがPlay 1.xで提供していたPythonのスクリプト群は、完全な機能を完備したビルドシステムではまったくありませんでしたし、カスタマイズも容易ではありませんでした。これが、私たちがPlay 2.0でさらに強力なビルドシステムへ舵を切ることを決めた理由です。</p>

    					<p>Play独自の規約をサポートでき、JavaとScalaのプロジェクトをビルドできるだけの柔軟性を持った、現代的なビルドツールが必要だったことから、私たちはSBTをPlay 2.0に統合することにしました。ただしこれによって、既存のPlayのビルドのシンプルさに満足しているユーザーが脅かされることがあってはなりません。私たちは、拡張性のあるモデルの上で、これまで同様のシンプルなplay new、run、startが体験できるようにしようとしています。Play 2.0は、ほとんどのユーザーにとっては、とにかく単純にうまく処理をこなしてくれる、設定済みのビルドスクリプトを持つことになります。一方で、アプリケーションのビルドやデプロイの方法を変更する必要がある場合は、Playのプロジェクトは標準的なSBTプロジェクトになるので、カスタマイズや特殊な要求への適用に応えるだけのあらゆるパワーを活用できるのです。</p>
    					<p>これはまた、Play 2.0はインストール直後から、Mavenとの統合がこれまでよりもうまくできているということでもあり、プロジェクトをシンプルなjarファイルの集合体としてパッケージ化し、任意のリポジトリへ公開できるということでもあり、さらには依存しているいかなる標準的なJavaあるいはScalaライブラリが開発中の状態であっても、ライブコンパイルやリローディングが可能だということでもあります。</p>
    				</div>

    				<h2>型安全性へのフォーカス</h2>
    				<div class="cols">

    					<p>Playのアプリケーションを書くための言語としてJavaを使う利点の一つは、Javaコンパイラがコードのある部分をチェックできるという点にあります。これは、開発プロセスの早期にミスを検出するのに有効であるのみならず、多くの開発者が参加する大規模なプロジェクトでの作業をとても容易にしてくれます。</p>
    					<p>Play 2.0の中にScalaを追加することで、私たちは間違いなく、コンパイラによるさらに強力な保障という利点を得ることになりますーしかし、それでもまだ十分ではありません。Play 1.xでは、テンプレートシステムは動的なものであり、Groovyに基づくもので、コンパイラにできることはそれほどありませんでした。その結果、テンプレートで発生するエラーは、実行時にしか検出できなかったのです。これは、コントローラとの間を取り持つコードの検証についても同じことが言えました。</p>
    					<p>私たちはPlay 2.0において、コードのほとんどをコンパイル時にチェックさせるという考え方をさらに推し進めたいと強く考えています。そのため、私たちはPlayのアプリケーションのデフォルトとして、Scalaベースのテンプレートエンジンを使うことに決めましたーこれは、Javaをメインのプログラミング言語として使う開発者にとっても、です。ただしだからといって、Play 1.xでテンプレートを書くために、Groovyを本当に知っていることが必要だったわけではないのと同様に、ScalaのエキスパートにならなければPlay 2.0でテンプレートを書くことができないということではありません。Scalaが主に使われるのは、Javaのシンタックスに極めて近いシンタックスを使って、必要な情報を表示するのにオブジェクトグラフをたどっていくためです。とはいえ、Scalaの持つパワーを生かして高度に抽象化されたテンプレートを書きたいなら、式指向で関数型であるScalaが、どれほどテンプレートエンジンにぴったりなのかは、すぐに理解できることでしょう。</p>
    					<p>そして、これはテンプレートエンジンにだけ言えることではありません。ルーティングのシステムもまた、完全に型が検査されることになります。Play 2.0は、ルートに関するすべての記述をチェックし、リバースルートの部分も含めて、すべてにおいて整合性が保たれているかどうかを検証します。</p>
    					<p>完全にコンパイルが行われることの嬉しい副作用として、テンプレートとルートファイルのパッケージ化と再利用が容易になることと、これらの部分の実行時のパフォーマンスの大幅な向上が見込めるということもあります。</p>
    				</div>

    				<h2>非同期処理への適応</h2>
    				<div class="cols">
    				    <p>今日のWebアプリケーションは、これまで以上にリアルタイムデータの並行処理を統合するようになってきており、Webフレームワークには完全な非同期HTTPプログラミングモデルをサポートすることが求められます。Play 1.xはまず、短期間に処理される大量のリクエストを処理する、クラシックなWebアプリケーションを扱うように設計されました。しかし今日では、comet、長期間のポーリング、WebSocketsを通じて、接続が保持され続けるコネクションを処理するため、イベントモデルへと進むべきです。</p>
    				    <p>Play 1.2はすでに、継続（continuation）を利用し、優れた非同期HTTPサポートを提供していました。Play 2.0のアーキテクチャは、最初からすべてのリクエストが潜在的に長期間保持されるものと見なして構築されます。私たちは、例えばControllerとWebsocketControllerという概念を、すべての要求を満たす単一のシンプルなモデルに一般化したいのです。</p>
    				    <p>しかし、これですべてというわけではありません。私たちには、長時間にわたって処理されるタスクのスケジューリングと実行を扱う、強力な方法も必要です。Play 1.0の元々のジョブモデルは、このために導入されたものですが、私たちにはもっと強力で頑健なモデルが、どうしても必要なのです。今日、並列度が非常に高いシステムを扱うモデルとしては、 Actorベースのモデルが最良であること、そしてJavaとScalaの双方で利用可能なActorベースのモデルの実装として、Akkaが最良のものであることは、疑問の余地がありませんーこれが、Akkaを使う理由です。私たちは、PlayのアプリケーションでAkkaをネイティブにサポートし、高度な分散システムを書くことができるようにします。</p>

    				</div>

    				<h2>データストアとモデルの統合</h2>
    				<div class="cols">
    				    <p>データストアは、もはや「SQLデータベース」の同義語ではありませんし、おそらくはこれまでもそうではありませんでした。データストアの興味深いモデルは、数多くのものが広く使われるようになり、様々なシナリオにおいて、様々な特徴が提供されてきました。そのため、PlayのようなWebフレームワークにとっては、開発者がどのようなデータストアを利用するのか、明確な推測をすることが難しくなってきたのです。Playにおける汎用的なplay.db.Modelの考え方は、単一のAPIでこういった技術のすべてを抽象化するのはほとんど不可能である以上、もはや意味を成さないものになってしまっています。</p>
    				    <p>私たちはPlay 2.0で、どのようなデータストアドライバ、ORMあるいはその他のデータベースアクセスライブラリも、特にこのフレームワークに統合することなく、容易に利用できるようにしたいと考えています。私たちは単に、コネクションのバインドの管理のような、一般的な技術的課題を扱うための、最小限のヘルパーを提供するようにしたいのです。とはいえ、私たちはまた、特殊な要求を持たないユーザーがクラシックなデータベースへアクセスするためのデフォルトのツールをバンドルすることで、Playフレームワークのフルスタックという性格も保ち続けたいと思っています。</p>
    				    <p>今日では、SQLデータベースへPlayのJavaアプリケーションからアクセスする方法として好まれているのは、Hibernateを利用しているPlayのModelライブラリです。しかし、PlayのようなステートレスなWebフレームワークにとって、JPAの公式仕様で定義されているような、ステートフルなエンティティを管理するのは面倒なことなので、私たちはできる限りステートレスに物事を扱うJPAの特別版を提供しました。そのために私たちがHibernateをハックせざるを得なかったやり方は、おそらく長期にわたって継続可能なやり方ではありません。この問題に対処するために、私たちはEBeanと呼ばれるステートレスなJPAの既存の実装に移行することを計画しました。舞台裏で使われているものが何なのか、それほど気にしないのであれば、これによって何かが変わることはほとんどありません。そして、本当にHibernateを使いたい場合や、さらにはJPAのその他の公式な実装をどうしても使いたいような場合にも、特にそれらはPlayに統合せずとも利用可能になります。また、Scalaの利用者のために、私たちはAnormもバンドルし続けます。</p>

    				</div>

    				<h2>現在のPlayユーザーにとっての変化</h2>
    				<div class="cols">
    				    <p>Play 2.0はメジャーリリースなので、それ以前のバージョンとAPIのレベルで互換になることは、おそらくありません。もちろんアーキテクチャのレベルでは、これまでと同じコンポーネントが、これまでと同じように構成されていることがおわかりいただけますし、さらに重要なことは、これまでと同じ「Play体験」を楽しんでいただけるということです。</p>
    				    <p><strong>既存のPlayのアプリケーションはどうなるんだろう？移行はどのくらい難しいんだろう？</strong></p>
    				    <p>心配は要りません。私たちは、既存のアプリケーションをPlay 2.0に移行していただこうとは考えていません。Play 1.x系バージョンのメンテナンスは継続されるので、Play 2.0へ移行しなければならないことはありません。私たち自身が、Play 1.xのWebアプリケーションを数多く実行しており、もちろんそれらのサポートは続けていきます。</p>

    				    <p><strong>覚えておいていただきたいのは、依然としてPlay 1.2.3は、JavaでWebアプリケーションを書くためのベストな方法であり、引き続きコアチームとコントリビューターの皆さんによるメンテナンスと開発が継続されるということで、これに対し、Play 2.0はまだ開発中なのです。Play 2.0は、次のプロジェクトや、アプリケーションの次の大幅な書き換えの際の移行先として、検討してください。</strong></p>
    				</div>

    				<h2>使ってみよう</h2>
    				<div class="col">
    				    <p>Play 2.0は、まだまだ開発が進められている最中であり、APIの変更も行われることになりますが、もうすでにプレビューバージョンをご覧いただくことが可能です。</p>
    				    <p><a href="http://download.playframework.org/releases/play-2.0-preview.zip">最初のプレビューバージョン</a> か、または <a href="http://github.com/playframework/play20">直接 GitHub で開発を追いかけてください</a> 。</p>

    				</div>

                </div>
				<a href="#" class="link">すべての発表を読み、ロードマップを見る</a>
			</article>

			<div class="tweet">
				<q>Woah... #playframework's new #scala template language looks awesome! <a href="http://bit.ly/mCR5Tu">http://bit.ly/mCR5Tu</a></q>

				<a href="http://twitter.com/#!/grandfatha/statuses/70586943544631296" class="author">
					<img src="http://a0.twimg.com/profile_images/1175953530/NwfUx_normal.jpeg" />
					<cite>K.D.</cite>
					<span>@grandfatha</span>
				</a>
			</div>

			<article id="features">

				<header>
					<h1>進捗確認</h1>
					<p>そして Play 2.0 新機能の発見</p>
				</header>
				${list.raw()}
				<div class="details">
					#{list items:details, as:'item'}
					<div id="${item.get('id')}" class="detail #{if item_index == 1}active#{/if}">
						<h3>lighthouse 上の関連するチケット</h3>
						${item.get('benefits').raw()}
					</div>
					#{/list}
				</div>

			</article>

			<div class="tweet">
				<q>So cool, Play framework rolles out Anorm - SQL data access with Scala <a href="http://bit.ly/rrpXUf">http://bit.ly/rrpXUf</a></q>
				<a href="http://twitter.com/#!/hofri/status/105333391746015233" class="author">
					<img src="http://a2.twimg.com/profile_images/300504667/foto_yehuda_normal.jpg" />
					<cite>yehuda hofri</cite>
					<span>@hofri</span>

				</a>
			</div>

			<article id="faq">
				<header>
					<h1>FAQs</h1>
					<p>ほとんど何も変わりません。しかし何もかも変わります。</p>
				</header>

				<div class="details">
					<div id="differencies">
						<div class="bloc">
						<h3>Play を使って新しいプロジェクトを作りたいのですが、Play 2.0 で始めるべきでしょうか?</h3>
						<p>
							Play 2.0 はまだまだ開発途中です。API は未完成で、変更されることになると思います。
							いまのところ Play 1.2.3 は Java で Web アプリケーションを書く最善の方法であり、
							2.0 のリリースのあとも引き続きコアチームと貢献者たちによって保守、開発されていきます。</p>
						</div>

						<div class="bloc">
						<h3>Play 2.0 が楽しみ! いつから自分のプロジェクトに利用できますか?</h3>
						<p>
							今年の終わりに向けて利用可能なベータバージョンをリリースする予定です。
							それまでは、アルファバージョンを試したり、
							上記のプログレスバーと Lighthouse でチームの作業を追いかけることができます。</p>
						</div>

						<div class="bloc">
						<h3>新しい機能はどれもこれもフレームワークを遅くしませんか?</h3>
						<p>
							Play 2.0 では、ほとんどすべてをコンパイル時に解決することによって、重要なパフォーマンスを改善する予定です。
							複雑なビルドシステムの導入は開発時におけるビルドのパフォーマンスを僅かながら劣化させるかもしれませんが、
							dev と prod モードのより良い分離のおかげで、実行時に影響を及ぼすことはないでしょう。
						</p>

						</div>

						<div class="bloc">
						<h3>なぜ Scala なのですか? 代わりに X 言語をサポートしてほしいのですが</h3>
						<p>
							私たちは、アプリケーションの可能な部分がほとんどコンパイラによってチェックされる、タイプセーフアプローチにフォーカスしていきたいと思っています。
							私たちは、Scala がタイプセーフな JVM 言語として、これからも勢いを増していくと信じています。
						</p>
						</div>

						<div class="bloc">
						<h3>機能 X はリリース 2.0 に含まれますか?</h3>
						<p>
							私たちは既に多数の変更をこのリリースに含めることを予定しており、
							<a href="http://en.wikipedia.org/wiki/Second-system_effect">Second System effect</a> は避けたいと思っています。
							しかし、私たちが何か本当に重要なことを見落としていると思ったら、気軽にメーリングリストで議論を始めてください。
						</p>
						</div>

						<div class="bloc">
						<h3>お手伝いがしたいのですが、Play 2.0 に貢献するにはどうしたらいいですか?</h3>
						<p>
							現在、私たちはプロジェクトの基盤：ビルドシステム、コンパイラ、基盤 API などを構築するために一所懸命作業しています。
							これら低レイヤの作業は、Play の主要な貢献者チームによってリードされています。
							これに参加するためには、開発のメーリングリストや課題管理システムを追いかけてください。
						</p>
						</div>

					</div>
				</div>
				<a href="https://groups.google.com/forum/#!forum/play-framework" class="link">他に質問はありますか? Play メーリングリストで質問してください。</a>
			</article>

			<div class="tweet">
				<q>play! framework is shockingly good</q>
				<a href="http://twitter.com/#!/whozman/status/28972750268" class="author">

					<img src="http://a1.twimg.com/profile_images/78167632/alex4_normal.jpg" />
					<cite>@whozman</cite>
					<span>@whozman</span>
				</a>
			</div>

			<div id="share">
				<div class="back">${twitter.raw()}</div>
				<div class="content">
					<p class="buttons">
						<a href="https://twitter.com/share?original_referer=http%3A%2F%2Fwww.playframework.org%2F2.0&source=tweetbutton&text=%23play2.0" class="tag">Share your thoughts about #play2.0</a>
					</p>
				</div>
			</div>
		</section>

	</body>
</html>

