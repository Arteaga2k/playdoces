h1. Completando las pruebas de la aplicación

Ya hemos terminado el sistema de blog que queríamos crear en esta guía. Sin embargo el proyecto en sí no está terminado aún. Para estar totalmente seguros de nuestro código necesitamos agregar más pruebas al proyecto.

Por supuesto nosotros ya hemos escritos pruebas unitarias con el fin de probar la funcionalidad de la capa modelo de yabe. Y es genial, ya que garantizará que el nucleo (_core_) del sistema de blog está bien probado. Pero una aplicación web no se basa solomente en el ‘modelo’. Necesitamos garantizar que la interfaz web funciona correctamente. Es decir, que necesitamos probar la capa controlador del sistema de blog. Pero también necesitamos probar la interfaz de usuario en sí, como por ejemplo, nuestro código JavaScript.

h2. <a name="controller">Probando la capa controlador</a>

Play provee una forma de probar directamente la capa controlador de la aplicación usando JUnit. A estas pruebas se le conoce con el nombre de **‘Pruebas Funcionales’**, ya que se utilizan para probar la funcionalidad completa de la aplicación web.

Básicamente una prueba funcional llama al @ActionInvoker@ de Play directamente, simulando una petición HTTP. A la que le espeficamos un método HTTP, una URI y parámetros HTTP. Entonces Play enruta la petición, invoca la acción correspondiente y devuelve la respuesta. Luego puedes analizarla para verificar que el contenido de la respuesta sea el esperado.

Vamos a escribir una primera prueba funcional. Abra le prueba unitaria @yabe/test/ApplicationTest.java@:

bc. import org.junit.*;
import play.test.*;
import play.mvc.*;
import play.mvc.Http.*;
import models.*;
 
public class ApplicationTest extends FunctionalTest {
 
    @Test
    public void testThatIndexPageWorks() {
        Response response = GET("/");
        assertIsOk(response);
        assertContentType("text/html", response);
        assertCharset("utf-8", response);
    }
    
}

Esto es muy similar a una prueba JUnit estándar por ahora. Note que usamos la super clase @FunctionalTest@ de Play con el fin de obtener todos los métodos de utilidad. Esta prueba está bien y solo verifica que la página de inicio (_home_) de la aplicación (normalmente el URL @/@) devuelve una respuesta HTML con código de estado **‘200 OK’**.

Ahora revisaremos que la seguridad del área de administración funcione correctamente. Agregue esta nueva prueba al archivo @ApplicationTest.java@:

bc. …
@Test
public void testAdminSecurity() {
    Response response = GET("/admin");
    assertStatus(302, response);
    assertHeaderEquals("Location", "/login", response);
}
…

Ahora ejecute la aplicación yabe en modo de prueba usando el comando @play test@, abra "http://localhost:9000/@tests":http://localhost:9000/@tests, seleccione el caso de prueba @ApplicationTest.java@ y ejecútelo.

¿Se muestra en color verde?

!images/guide10-1!

Bien, podríamos continuar probando todas las funcionalidades de la aplicación de esta forma, pero no es la mejor manera de probar una aplicación web basada en HTML. Como nuestro sistema de blog está destinado a ser ejecutado en un navegador web, sería mejor probarlo directamente en un **navegador web de verdad**. Y esto es exactamente lo que hacen las **‘pruebas Selenium’** de Play.

Este tipo de **‘Pruebas Funcionales’** basadas en Junit son útiles aún, normalmente para probar Servicios Web que devuelven respuestas que no son HTML, tales como JSON o XML sobre HTTP.

h2. <a name="selenium">Escribiendo pruebas Selenium</a>

"Selenium":http://seleniumhq.org es una herramienta de pruebas diseñada específicamente para probar aplicaciones web. Lo interesante aquí es que Selenium permite ejecutar la _suite_ de pruebas directamente en cualquier navegador existente. Como no utiliza ningun ‘navegador simulado’, usted puede estar seguro de que lo que está probando es lo que los usuarios usarán.

Normalmente, una _suite_ de prueba Selenium se escribe en un archivo HTML. La sintaxis HTML que requiere Selenium es un poco tediosa de escribir (formateado usando una tabla HTML). La buena noticia es que Play le ayuda a generarla usando el sistema de plantillas de Play y un conjunto de tags que soportan una sintaxis simplificada para esceneraios Selenium. Un efecto secundario interesante de usar plantillas es que usted ya no está atado a ‘escenarios estáticos’ y puede usar el poder de las plantillas Play (bloques condicionales, ciclos, etc) para escribir pruebas más complicadas.

p(note). Sin embargo, todavía puede utilizar la sintaxis HTML normal de Selenium en la plantilla y olvidarse de los tags específicos de Selenium si es necesario. Puede ser interesante si usa una de las diversas herramientas Selenium que generan los escenarios de prueba por usted, como por ejemplo "Selenium IDE":http://seleniumhq.org/projects/ide.

La _suite_ de prueba por defecto de una aplicación Play recien creada ya contiene una prueba Selenium. Abra el archivo @yabe/test/Application.test.html@:

bc. *{ You can use plain Selenium commands using the selenium tag }*
 
#{selenium}
    // Open the home page, and check that no error occurred
    open('/')
    waitForPageToLoad(1000)
    assertNotTitle('Application error')
#{/selenium}

Esta prueba debería ejecutarse sin ningún problema con la aplicación yabe. Ya que solo abre la página de inicio y verifica que el contenido de la página no incluya el texto ‘Application error’.

No obstante, como cualquier prueba compleja, necesita configurar un conjunto de datos bien conocidos antes de navegar la aplicación y probarla. Por supuesto reutilizaremos el concepto de _fixture_ y el archivo @yabe/test/data.yml@ que usamos anteriormente. Para importar estos datos antes de ejecutar la _suite_ de prueba, solo utilice el tag @#{fixture /}@:

bc. #{fixture delete:'all', load:'data.yml' /}
 
#{selenium}
    // Open the home page, and check that no error occurred
    open('/')
    waitForPageToLoad(1000)
    assertNotTitle('Application error')
#{/selenium}

Otro aspecto importante que se debe revisar es que tengamos una sesión de usuario limpia al inicio de la prueba. La sesión se almacena en un _cookie_ temporal del navegador, la cual mantendría la misma sesión durante dos ejecuciones de prueba sucesivas.

Así que vamos a empezar nuestra prueba con un comando especial:

bc. #{fixture delete:'all', load:'data.yml' /}
 
#{selenium}
    clearSession()
 
    // Open the home page, and check that no error occurred
    open('/')
    waitForPageToLoad(1000)
    assertNotTitle('Application error')
#{/selenium}

Ejecútela para estar seguros de que no hay errores. Debería mostrarse en color verde.

Ahora podemos escribir una prueba más específica. Abrir la página de inicio y revisar que los posts por defecto están presentes:

bc. #{fixture delete:'all', load:'data.yml' /}
 
#{selenium 'Check home page'}
    clearSession()
 
    // Open the home page
    open('/')
 
    // Check that the front post is present
    assertTextPresent('About the model layer')
    assertTextPresent('by Bob, 14 Jun 09')
    assertTextPresent('2 comments , latest by Guest')
    assertTextPresent('It is the domain-specific representation')
 
    // Check older posts
    assertTextPresent('The MVC application')
    assertTextPresent('Just a test of YABE')
#{/selenium}

Usamos la sintaxis estándar de Selenium, llamada "Selenese":http://seleniumhq.org/docs/02_selenium_ide.html#selenium-commands-selenese.

Ejecútela (puede ejecutarla en una ventana diferente solo con abrir el enlace de prueba en una ventana nueva).

!images/guide10-2!

Ahora probaremos el formulario de comentarios. Solo agregue un nuevo tag @#{selenium /}@ a la plantilla:

bc. #{selenium 'Test comments'}
 
    // Click on 'The MVC application post'
    clickAndWait('link=The MVC application')
    assertTextPresent('The MVC application')
    assertTextPresent('no comments')
    
    // Post a new comment
    type('content', 'Hello')
    clickAndWait('css=input[type=submit]')
    
    // Should get an error
    assertTextPresent('no comments')
    assertTextPresent('Author is required')
    type('author', 'Me')
    clickAndWait('css=input[type=submit]')
    
    // Check
    assertTextPresent('Thanks for posting Me')
    assertTextPresent('1 comment')
    assertTextPresent('Hello')
#{/selenium}

Y ejecútela. Se produce un error; y tenemos un serio problema aquí.

!images/guide10-3!

En realidad no podemos probar correctamente el mecanismo de _captcha_, así que tenemos que engañarlo. En modo de prueba validaremos cualquier código como un captcha correcto. Sabemos que estamos en modo de prueba cuando el id del framework es @test@. Así que vamos a modificar la acción @postComment@ en el archivo @yabe/app/controllers/Application.java@ para saltar está validación cuando estemos en modo de prueba:

bc. …
if(!Play.id.equals("test")) {
    validation.equals(code, Cache.get(randomID)).message("Invalid code. Please type it again");
}
…

Ahora solo modifique el caso de prueba para que escriba cualquier código en el campo de texto, de esta manera:

bc. …
type('author', 'Me')
type('code', 'XXXXX')
clickAndWait('css=input[type=submit]')
…

Y ahora ejecute la prueba otra vez, debería funcionar.

h2. <a name="cobertura">Midiendo la cobertura de código</a>

Está claro que no hemos escrito todos los casos de prueba que requiere la aplicación. Pero esto es suficiente para este tutorial. Ahora en un proyecto de verdad, ¿cómo podemos saber si hemos escrito suficientes casos de prueba? Necesitamos algo llamado **‘cobertura de código’**.

El "módulo Cobertura":http://www.playframework.org/modules/cobertura genera reportes de cobertura de código usando la herramienta "Cobertura":http://cobertura.sourceforge.net/. Instale el módulo utilizando el comando @install@:

bc. play install cobertura-{version}

Necesitamos habilitar este módulo solo para el modo de prueba. Así que agregue esta línea al archivo @application.conf@, y reinicie la aplicación en modo de prueba.

bc. # Import the cobertura module in test mode
%test.module.cobertura=${play.path}/modules/cobertura

Ahora abra nuevamente la URL "http://localhost:9000/@tests":http://localhost:9000/@tests en el navegador, seleccione todas las pruebas y ejecútelas. Todo debería mostrarse en verde.

!images/guide10-5!

Cuando todas las pruebas sean exitosas, detenga la aplicación y Cobertura generará entonces el reporte de cobertura de código. Luego puede abrir el archivo @yabe/test-result/code-coverage/index.html@ en su navegador y revisar el reporte.

!images/guide10-4!

Si inicia la aplicación nuevamente, también puede verlo en "http://localhost:9000/@cobertura":http://localhost:9000/@cobertura.

Como puede ver estamos lejos de probar todos los casos de la aplicación. Una buena _suite_ de pruebas debería estár cerca del 100%, aunque por supuesto es casi imposible probar todo el código. Normalmente porque con frecuencia necesitamos saltar códigos cuando estamos en modo de prueba, tal como hicimos con el captcha.

p(note). Continúa con: %(next)"Preparando la puesta en producción":guide11%. 
