p(note). Esta página todavía no ha sido traducida al castellano. Si quieres colaborar con nosotros y ayudar con la traducción lee nuestra "guía para colaborar con la traducción de play":translation.

h1. El motor de templates

Play cuenta con un eficiente motor de templates que le permite generar HTML, XML, JSON o cualquier documento de texto de manera dinámica. El motor de templates utiliza "Groovy":http://groovy.codehaus.org/ como lenguaje de expresiones. Un sistema de tags le permite crear funciones reutilizables.

Los templates son almacenados en la carpeta @app/views@. 

h2. <a name="syntax">Sintaxis de los templates</a>

Un template es un archivo de texto en el cual algunas de sus partes serán remplazadas por contenido generado dinámicamente. Los elementos dinámicos de los templates son escritos utilizando el lenguaje "Groovy":http://groovy.codehaus.org/ language. Groovy es un lenguaje cuya sintaxis es muy similar a la de Java.
Groovy’s syntax is very close to Java’s. 

h3. Expresiones: ${…}

La manera más simple de crear un elemento dinámico es declarando una expresión. La sintaxis utilizada es @${…}@. De esta manera, el resultado de evaluar dicha expresión será insertado en lugar de la expresión misma.

Por ejemplo:

bc. <h1>Client ${client.name}</h1>

Si no puede asegurar que el nombre del cliente no será null, Groovy provee un práctico atajo para estos casos:

bc. <h1>Client ${client?.name}</h1>

De forma tal que sólo mostrará el nombre del cliente si el mismo no es null.

h3. Decoradores: #{extends  /} and  #{doLayout  /}

Los decoradores proveen una simple y elegante solución para compartir el diseño de una página ente múltiples templates.

p(note). Utilice los tags "#{get}":tags#ageta y "#{set}":tags#aseta para compartir variables entre el template y el decorador.

De esta manera, puede incluir una página en un decorador con una línea de código:

bc. #{extends 'simpledesign.html' /}
 
#{set title:'A decorated page' /}
This content will be decorated.

El decorador : @simpledesign.html@

bc. <html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <title>#{get 'title' /}</title>
  <link rel="stylesheet" type="text/css" href="@{'/public/stylesheets/main.css'}" />
</head>
<body>
  <h1>#{get 'title' /}</h1>
  #{doLayout /}
  <div class="footer">Built with the play! framework</div>
</body>
</html>

h3. Tags: #{nombreDeTag /}

Un tag es un framento de un template que puede ser llamado con parametros, como si se tratara de una función. Si el tag cuenta con un único parámetro, por convención dicho parámetros se llamará "arg" y su nombre puede ser omitido.

Por ejemplo, este tag inserta un tag SCRIPT para cargar un archivo JavaScript:

bc. #{script 'jquery.js' /}

Un tag necesariamente tiene que ser cerrado, ya sea directamente o mediante un tag de cierre:

bc. #{script 'jquery.js' /}

o

bc. #{script 'jquery.js'}#{/script}

Por ejemplo, el tag @list@ le permite iterar sobre los elementos de cualquier colección. Requiere dos parámetros obligatorios:

bc. <h1>Client ${client.name}</h1>
<ul>
    #{list items:client.accounts, as:'account' }
        <li>${account}</li>
    #{/list}
</ul>

Todas las expresiones dinámicas son automáticamente escapadas por el motor de templates para evitar ataques XSS en su aplicación. De forma tal que la variable @title@ que contiene <code>==&lt;h1>Title&lt;/h1>==</code> será escapada de la siguiente manera:

bc. ${title} --> &lt;h1&gt;Title&lt;/h1&gt;

Si desea evitar que Play escape el contenido de la expresión, debe llamar al método @raw()@:

bc. ${title.raw()} --> <h1>Title</h1>

Si desea evitar que una porción grande de código HTML sea escapada, puede utilizar el tag @#{verbatim /}@:

bc. #{verbatim}
    ${title} --> <h1>Title</h1>
#{/verbatim}

h3. Acciones: @{…} o @@{…}

Puede utilizar el Router para generar (o incluso generar de manera inversa) el URL correspondiente a una ruta especificada. Desde un template puede utilizar la sintaxis <code>@{…}</code> para alcanzar el mismo efecto.

Por ejemplo:

bc. <h1>Client ${client.name}</h1>
<p>
   <a href="@{Clients.showAccounts(client.id)}">All accounts</a>
</p>
<hr />
<a href="@{Clients.index()}">Back</a>

La sintaxis <code>@@{…}</code> hace lo mismo pero genera un URL absoluto (lo cual es particulamente útil para general e-mails)

h3. Mensajes: &{…}

Si su aplicación requiere poder ser internacionalizada, puede utilizar la sintaxis @&{…}@ para desplegar un mensaje internacionalizado:

Por ejemplo en el archivo @conf/messages@ especificamos:

bc. clientName=The client name is %s

Para mostrar este mensaje en un template simplemente use:

bc. <h1>&{'clientName', client.name}</h1>

h3. Comentarios: ==*{…}*==

Los cometarios no son evaluados por el motor de template. Simplemente son comentarios…

bc. *{**** Display the user name ****}*
<div class="name">
    ${user.name}
</div>

h3. Scripts: ==%{…}%==

Un script es un conjunto de expresiones con una lógica más compleja. Un script puede declarar algunas variables y definir varios comandos. Utilice la sintaxis @%{…}%@ para insertar scripts.

bc. %{
   fullName = client.name.toUpperCase()+' '+client.forname;
}%
 
<h1>Client ${fullName}</h1>

Mediante un script puede escribir contenido dinámico directamente usando el objeto @out@:

bc. %{
   fullName = client.name.toUpperCase()+' '+client.forname;
   out.print('<h1>'+fullName+'</h1>');
}%

Puede utilizar un script para crear una estructura que le permita interar sobre los elementos de una colección:

bc. <h1>Client ${client.name}</h1>
<ul>
%{
     for(account in client.accounts) { 
}%
     <li>${account}</li>
%{
     }
}%
</ul>

Tenga en cuenta que los templates no es el mejor lugar para introducir lógica completa. En tal caso es aconsejable crear un tag, o mover esa lógica hace el controlador o el modelo de objetos.

h2. <a name="inheritance">Herencia de templates</a>

Un template puede heredar el contenido de otro template, es decir que puede ser incluido como parte de otro template.

Para heredar de otro template, utilice el tag @extends@:

bc. #{extends 'main.html' /}
 
<h1>Some code</h1>

El template @main.html@ es un template común y corriente, pero utiliza el tag @doLayout@ para incluir el contenido de aquél template que lo herede:

bc. <h1>Main template</h1>
 
<div id="content">
    #{doLayout /}
</div>


h2. <a name="tags">Tags personalizados</a>

Puede crear sus propios tags de manera muy simple. Un tag no es más que un archivo de template, almacenado en la carpeta @app/views/tags@. El nombre del archivo del tag es utilizado como nombre del tag.

Para crear un tag @hello@, simplemente cree el archivo @app/views/tags/hello.html@.

bc. Hello from tag!

No hay necesidad de configurar nada. Puede usar el tag directamente de la siguiente manera:

bc. #{hello /}

h3. Definiendo tags con parámetros

Los parámetros de los tags son expuestos como variables de un tempalte. Los nombres de variables con construido con el prefijo ‘_’.

Por ejemplo, dado el siguiente tag: 

bc. Hello ${_name} !

Puede pasar el nombre como un parámetro al tag:

bc. #{hello name:'Bob' /}

Si el tag cuenta con tan sólo un parámetro, puede acceder al mismo de manera implícita mediante el nombre @arg@.

Por ejemplo:

bc. Hello ${_arg}!

Y puede llamarlo fácilmente usando:

bc. #{hello 'Bob' /}

h3. Invocando el body (cuerpo) de un tag

Si su tag acepta un body (cuerpo), puede incluirlo en el código de su tag usando el tag @doBody@.

Por ejemplo:

bc. Hello #{doBody /}!

Y luego puede pasar el nombre en el cuerpo del tag:

bc. #{hello}
   Bob
#{/hello}

h3. Format-specific tags

You can have different versions of a tag for different "content types":routes#content-types and Play will select the appropriate tag. For example, Play will use the @app/views/tags/hello.html@ tag when @request.format@ is @html@, and @app/views/tags/hello.xml@ when the format is @xml@.

Whatever the content type, Play will fall back to the @.tag@ extension if a format-specific tag is not available, e.g. @app/views/tags/hello.tag@.


h2. <a name="fasttags">Custom Java tags</a>

You can also define custom tags in Java code. Similarly to how JavaExtensions work by extending the @play.templates.JavaExtensions@ class, to create a FastTag you need to create a method in a class that extends @play.templates.FastTags@. Each method that you want to execute as a tag must have the following method signature.

bc. public static void _tagName(Map<?, ?> args, Closure body, PrintWriter out, 
   ExecutableTemplate template, int fromLine)

p(note). Note the underscore before the tag name.

To understand how to build an actual tag, let’s look at two of the built-in tags.

For example, the @verbatim@ tag is implemented by a one-line method that simply calls the toString method on the JavaExtensions, and passes in the body of the tag.

bc. public static void _verbatim(Map<?, ?> args, Closure body, PrintWriter out, 
   ExecutableTemplate template, int fromLine) {
   
   out.println(JavaExtensions.toString(body));
}

The body of the tag would be anything between the open and close tag. So

bc. <verbatim>My verbatim</verbatim>

The body value would be 

bc. My verbatim

The second example is the @option@ tag, which is slightly more complex because it relies on a parent tag to function.

bc. public static void _option(Map<?, ?> args, Closure body, PrintWriter out, 
      ExecutableTemplate template, int fromLine) {
 
   Object value = args.get("arg");
   Object selection = TagContext.parent("select").data.get("selected");
   boolean selected = selection != null && value != null 
      && selection.equals(value);
 
   out.print("<option value=\"" + (value == null ? "" : value) + "\" " 
      + (selected ? "selected=\"selected\"" : "") 
      + "" + serialize(args, "selected", "value") + ">");
   out.println(JavaExtensions.toString(body));
   out.print("</option>");
}

This code works by outputting an HTML @option@ tag, and sets the selected value by checking which value is selected from the parent tag. The first three lines set variables for use in the output output. Then, the final three lines output the result of the tag.

There are many more examples in the source code for the built in tags, with varying degrees of complexity. See "FastTags.java in github":https://github.com/playframework/play/blob/master/framework/src/play/templates/FastTags.java.

h3. Tag namespaces

To ensure that your tags do not conflict between projects, or with the core Play tags, you can set up namespaces, using the class level annotation <code>@FastTags.Namespace</code>.

So, for a @hello@ tag, in a @my.tags@ namespace, you would do the following

bc. @FastTags.Namespace("my.tags") 
public class MyFastTag extends FastTags {
   public static void _hello (Map<?, ?> args, Closure body, PrintWriter out, 
      ExecutableTemplate template, int fromLine) {
      ...
   }
}

and then in your templates, you would reference the hello tag as

bc. #{my.tags.hello/}



h2. <a name="extensions">Java object extensions in templates</a>

When you use your Java object within the template engine, new methods are added to it. These methods don’t exist in the original Java class and are dynamically added by the template engine.

For example, to allow easy number formatting in a template, a @format@ method is added to @java.lang.Number@.

It’s then very easy to format a number:

bc. <ul>
#{list items:products, as:'product'}
    <li>${product.name}. Price: ${product.price.format('## ###,00')} €</li>
#{/list}
</ul>

The same applies to @java.util.Date@.

The "Java extensions":javaextensions manual page lists the available methods, by type.


h3. Create custom extensions

Your project may have specific formatting needs, in which case you can provide your own extensions.

You only need to create a Java class extending @play.templates.JavaExtensions@.

For instance, to provide a custom currency formatter for a number:

bc. package ext;
 
import play.templates.JavaExtensions;
 
public class CurrencyExtensions extends JavaExtensions {
 
  public static String ccyAmount(Number number, String currencySymbol) {
     String format = "'"+currencySymbol + "'#####.##";
     return new DecimalFormat(format).format(number);
  }
 
}

Each extension method is a static method and should return a @java.lang.String@ to be written back in the page. The first parameter will hold the enhanced object.

Use your formatter like this:

bc. <em>Price: ${123456.324234.ccyAmount()}</em>

Template extension classes are automatically detected by Play at start-up. You just have to restart your application to make them available.

h2. <a name="implicits">Implicit objects available in a template</a>

All objects added to the @renderArgs@ scope are directly injected as template variables. 

For instance, to inject a ‘user’ bean into the template from a controller:

bc. renderArgs.put("user", user );

When you render a template from an action, the framework also adds implicit objects:

|| Variable || Description || API documentation || See also ||
| @errors@ | Validation errors | "play.data.validation.Validation.errors()":/@api/play/data/validation/Validation.html#errors%28%29 | "Validating HTTP data":validation |
| @flash@ | Flash scope | "play.mvc.Scope.Flash":/@api/play/mvc/Scope.Flash.html  | "Controllers - Session & Flash Scope":controllers#session |
| @lang@ | The current language | "play.i18n.Lang":/@api/play/i18n/Lang.html | "Setting up I18N - Define languages":i18n#languages |
| @messages@ | The messages map | "play.i18n.Messages":/@api/play/i18n/Messages.html | "Setting up I18N - Externalize messages":i18n#messages |
| @out@ | The output stream writer | java.io.PrintWriter |  |
| @params@ | Current parameters | "play.mvc.Scope.Params":/@api/play/mvc/Scope.Params.html  | "Controllers - HTTP parameters":controllers#params |
| @play@ | Main framework class | "play.Play":/@api/play/Play.html |  |
| @request@ | The current HTTP request | "play.mvc.Http.Request":/@api/play/mvc/Http.Request.html  |  |
| @session@ | Session scope | "play.mvc.Scope.Session":/@api/play/mvc/Scope.Session.html  | "Controllers - Session & Flash Scope":controllers#session |

In addition to the list above the names @owner@, @delegate@ and @it@ are reserved in Groovy and shouldn't be used as variable names in templates.

p(note). Next: %(next)"Form data validation":validation%
