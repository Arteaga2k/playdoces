
h1. Jobs Asíncronos

Como Play es un marco de apliaciones web, la mayor parte de la lógica de la aplicación la hacen los controladores en respuesta a solicitudes HTTP. 

Pero a veces necesitas ejecutar algo de lógica de la aplicación fuera de cualquier request HTTP. Esto puede ser útil para tareas de inicialización, de mantenimiento, o para ejecutar tareas largas sin bloquear la pool de ejecución de las requests HTTP.

Los Jobs están controlados completamente por el marco. Esto quiere decir que Play gestionará todo el tema de conexión a la base de datos, el gestor de entidades JPA, el control de la sincronización y las transacciones. Para crear un job basta con extender la superclase @play.jobs.Job@.

bc.. package jobs;
 
import play.jobs.*;
 
public class MyJob extends Job {
    
    public void doJob() {
        // ejecutar aqui la logica de la aplicacion ...
    }
    
}

p. A veces necesitas crear jobs que devuelvan un resultado. En estos casos tienes que sobrecargar el método @doJobWithResult()@.

bc.. package jobs;
 
import play.jobs.*;
  
public class MyJob extends Job<String> {
    
    public String doJobWithResult() {
        // ejecutar aqui la logica de la aplicacion ...
        return result;
    }
    
}

p. Aquí el uso de @String@ es sólo un ejemplo. Por supuesto un job puede devolver cualquier tipo de objeto.

h2. <a name="concepts">Jobs de arranque (Bootstrap)</a>

Los jobs de arranque (bootstrap) los ejecuta Play al arrancar la aplicación. Para marcar el job como bootstrap basta añadir la anotación <code>@OnApplicationStart</code>.

bc.. import play.jobs.*;
 
@OnApplicationStart
public class Bootstrap extends Job {
    
    public void doJob() {
        if(Page.count() == 0) {
            new Page("root").save();
            Logger.info("Se ha creado una pagina principal.");
        }
    }
    
}

p. No necesitas devolver un resultado. Incluso si lo haces, el resultado se perderá.

Por defecto, todos los jobs anotados con <code>@OnApplicationStart</code> se ejecutarán en secuencia. Cuando se terminen todos los jobs, la aplicación está lista para empezar a procesar las request que entren.

Si quieres que tus jobs arranquen junto con la aplicación, pero quieres empezar a procesar las request inmediatamente, puedes anotar el job con esto: <code>@OnApplicationStart(async=true)</code>. De esta forma tu job se arrancará en el background cuando arranque la aplicación. Todos los jobs asíncronos se arrancarán a la vez.

p(note). **Atención**
 
Cuando ejecutas la aplicación en modo DEV, la aplicación espera a la primera request HTTP para arrancar. Además, cuando estás en el modo DEV, la aplicación se rearrancará automáticamente cuando sea necesario.

Cuando estás en modo PROD, la aplicación arrancará síncronamente cuando arranque el servidor.

h2. <a name="scheduling">Jobs Programados</a>

El marco ejecuta los jobs programados periódicamente. Puedes pedirle a Play que ejecute un job en un intervalo específico mediante la anocación <code>@Every</code>.

bc.. import play.jobs.*;
 
@Every("1h")
public class Bootstrap extends Job {
    
    public void doJob() {
        List<User> newUsers = User.find("newAccount = true").fetch();
        for(User user : newUsers) {
            Notifier.sayWelcome(user);
        }
    }
    
}

p. Si la anotación <code>@Every</code> no es suficiente, puedes usar la anotación <code>@On</code> para ejecutar los jobs usando una expresión CRON.

bc.. import play.jobs.*;
 
/** Fire at 12pm (noon) every day **/ 
@On("0 0 12 * * ?")
public class Bootstrap extends Job {
    
    public void doJob() {
        Logger.info("Maintenance job ...");
        ...
    }
    
}

p(note). **Nota**

Usamos el analizador de expresiones CRON de "Quartz library":http://www.quartz-scheduler.org/docs/tutorials/crontrigger.html.

No necesitas devolver un resultado. Si lo haces, el resultado se perderá.


h2. <a name="tasks">Accionar jobs de tareas</a>

También se puede accionar un Job en cualquier momento para que ejecute una tarea específica, simplemente llamando a  @now()@ en uns instancia de Job. Este job se ejecutará inmediatamente de forma no bloqueante.. 

bc. public static void encodeVideo(Long videoId) {
    new VideoEncoder(videoId).now();
    renderText("Empieza Codificacion");
}

Una llamada a @now()@ sobre un Job devuelve un valor @Promise@ que puede usarse para recuperar el resultado de la tarea cuando finalice.

h2. <a name="concepts">Parado de la aplicación</a>

Como a veces tienes que ejecutar alguna acción antes del parado de la aplicación, Play también incluye una anotación <code>@OnApplicationStop</code>.

bc.. import play.jobs.*;
 
@OnApplicationStop
public class Bootstrap extends Job {
 
    public void doJob() {
        Fixture.deleteAll();
    }
}

p(note). **Continuando la discusión**

Veamos ahora cómo combinar Jobs con la más potente %(next)"Programación Asíncrona con HTTP":asynchronous%.
