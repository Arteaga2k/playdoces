p(note). Esta página todavía no ha sido traducida al castellano. Si quieres colaborar con nosotros y ayudar con la traducción lee nuestra "guía para colaborar con la traducción de play":translation.

h1. Validando información HTTP con Play

Las validaciones nos permiten asegurar que la información tiene ciertos valores o que cumple con requerimientos específicos. Puede utilizar las validaciones para verificar que la información de sus modelos sea correcta antes de grabarlos a la base de datos, o utilizarlas directaemente para validar los parámetros HTTP recibidos desde un formulario.

h2. <a name="how">Cómo funciona la validación en Play</a>

Cada pedido HTTP tiene su propio objeto @Validation@ en el cual se guardan los errores. Hay tres maneras de definir validaciones.

# <span>En un método de un controlador, llamando métodos en el campo @validation@ del controlador de manera directa. También puede acceder a un subconjunto de la API utilizando los métodos estáticos de la clase @play.data.validation.Validation@.</span> 
# <span>Agregando anotaciones de validaciones a los parámetros declarados en la firma de los métodso de un controlador.</span>
# <span>Agregando la anotación <code>@Valid</code> a los métodos de acción que reciben un POJO como parámetro, y agregando las correspondientes anotaciones de validación en las propiedades del POJO.</span> 

El objeto validation mantiene una coelcción de objetos de tipo @play.data.validation.Error@ objects. Cada uno de estos errores cuenta con dos propiedades:

* La clave o @key@. Esta propiedad ayuda a determinar cuál es el elemento que causó el error. La clave puede ser fijada arbitrariamente, pero cuando Play genera un error, por defecto utiliza el nombre de la variable Java.

* El mensaje o @message@, el cual conteiene la descripción textual del error detectado. El mensaje puede ser un texto plano o referirse a la clave de un mensaje internacionalizado.

Veamos cómo podemos validar un simple parámetro HTTP utilizando el primer enfoque:

bc. public static void hello(String name) {
     validation.required(name);
     …
}

Este código verifica que la variable name haya sido correctamente establecida. En caso contrario, el correspondiente error es agregado a la colección de errores.

Puede repetir esta operación para cada validación que precise efectuar:

bc. public static void hello(String name, Integer age) {
     validation.required(name);
     validation.required(age);
     validation.min(age, 0);
     …
}

h2. <a name="messages">Mensajes de errores de validación</a>

Al finalizar la validación de la información, puede verificar si ha ocurrido algún error y desplegarlos:

bc. public static void hello(String name, Integer age) {
     validation.required(name);
     validation.required(age);
     validation.min(age, 0);
     
     if(validation.hasErrors()) {
         for(Error error : validation.errors()) {
             System.out.println(error.message());
         }
     }
}

En caso de que name y age sean @null@, este controlador desplegaría:

bc. Required
Required

Esto se debe a que el mensaje por defecto, definido en @$PLAY_HOME/resources/messages@, es:

bc. validation.required=Required

Hay tres maneras de personalizar este mensaje de validación.

# <span>Sobreescribir el mensaje por defecto, redefiniendo el mensaje en el archivo @messages@ de su aplicación.</span> 
# <span>Pasando un mensaje personalizado como un parámetro adicional a la validación.</span>
# <span>Brindando una clave en un archivo de internacionalización para ese mensaje, pasándlo como un parámetro adicional a la validación.</span> 

h3. Mensajes de validación internacionalizados

La manera más simple de sobreescribir estos mensajes, es utilizar la misma clave de mensaje para un mensaje definid en el archivo @conf/messages@. Por ejemplo:

bc. validation.required = Please enter a value 

También puede proveer mensajes en otros idiomas, tal como se describe en la página de "Internacionalización":i18n. 

h3. Parámetros de los mensajes de validación

Puede utilizar un marcador de posición (placeholder) en el mensaje asociado con una clave de error:

bc. validation.required=%s is required

De esta manera, la salida del error anterior sería:

bc. name is required
age is required

p(note). *Limitación*: Play no puede determinar el nombre del parámetro cuando se define más de una validación de campo requerido utilizando la sintaxis @validation.required(age)@. En ese caso, debe especificar el nombre del campo de la siguiente manera: @validation.required("age", age)@.

Como clave del error se asume por defecto el nombre del parámetro, y es utilizao para buscar el mensaje. Por ejemplo, el parámetro @name@ en el método de acción @hello@ podría ser internacionalizado de la siguiente manera:

bc. name = Customer name

De manera que la salida del error quedaría como:

bc. Customer name is required
age is required

También puede sobreescribir la clave del error utilizando el método @error.message(String key)@. Por ejemplo:

bc. Error error = validation.required(name).error;
if(error != null) {
    System.out.println(error.message("Customer name"));
}

Several of the built-in validations define additional message parameters that correspond to the validation parameters. For example, the 'match' validation defines a second @String@ parameter for the specified regular expression, which differs from the @%s@ placeholder above in that it specifies the parameter index ‘2’: 

bc. validation.match=Must match %2$s 

Similarly, the 'range' validation defines two additional numeric parameters, with indices 2 and 3: 

bc. validation.range=Not in the range %2$d through %3$d 

Look in the file @$PLAY_HOME/resources/messages@ to see which other validations have parameters. 

h3. Custom localised validation messages 

The validation messages in @$PLAY_HOME/resources/messages@ use the default message key for each of Play’s "built-in validations":validation-builtin. You can specify a different message key. For example: 

bc. validation.required.em = You must enter the %s! 


Use this new message key for the message, for manual validation in the action method: 

bc. validation.required(manualKey).message("validation.required.em"); 


Alternatively, use the key in the annotation’s @message@ parameter: 

bc. public static void hello(@Required(message="validation.required.em") String name) { 
   …
} 


You can use the same technique with validation annotations on JavaBean properties: 

bc. public static void hello(@Valid Person person) { 
   …
} 
 
public class Person extends Model { 
   @Required(message = "validation.required.emphasis")
   public String name; 
   … 
} 

h3. Custom literal (non-localised) validation messages 

The Play message look-up just returns the message key if there is no message defined for the key, which means you can also just use a literal message instead of the message key if you prefer. Using the same examples as above, for manual validation: 

bc. validation.required(manualKey).message("Give us a name!"); 

For action method parameter annotations: 

bc. public static void save(@Required(message = "Give us a name!") String name) { 
   …
} 

For JavaBean property annotations: 

bc. public static void save(@Valid Person person) { 
   …
}
 
public class Person extends Model {
   @Required(message = "Give us a name!")
   public String name; 
   … 
} 




h2. <a name="display">Displaying validation errors in the template</a>

In most cases you want to display the error messages in the view template. You can access them in the template using the @errors@ object. Some tags help you to display the errors:

Let’s see a sample:

bc. public static void hello(String name, Integer age) {
   validation.required(name);
   validation.required(age);
   validation.min(age, 0);
   render(name, age);
}

and now the template:

bc. #{ifErrors}
 
   <h1>Oops…</h1>
 
   #{errors}
       <li>${error}</li>
   #{/errors}
 
#{/ifErrors}
#{else}
 
   Hello ${name}, you are ${age}.
 
#{/else}

But in a real application you want to redisplay the original form. So you will have two actions: one to display the form and another one to handle the POST. 

Of course the validation will occur in the second action and if some error occurs you will have to redirect to the first action. In this case you need a special trick to keep your errors during the redirect. Use the @validation.keep()@ method. This will save the errors collection for the next action.

Let’s see a real sample:

bc. public class Application extends Controller {
 
   public static void index() {
      render();
   }
 
   public static void hello(String name, Integer age) {
      validation.required(name);
      validation.required(age);
      validation.min(age, 0);
      if(validation.hasErrors()) {
          params.flash(); // add http parameters to the flash scope
          validation.keep(); // keep the errors for the next request
          index();
      }
      render(name, age);
   }
 
}

And the @view/Application/index.html@ template:

bc. #{ifErrors}
   <h1>Oops…</h1>
 
   #{errors}
       <li>${error}</li>
   #{/errors}
#{/ifErrors}
 
#{form @Application.hello()}
   <div>
      Name: <input type="text" name="name" value="${flash.name}" />
   </div>
   <div>
      Age: <input type="text" name="age" value="${flash.age}" /> 
   </div>
   <div>
      <input type="submit" value="Say hello" /> 
   </div>
#{/form}

You can create a better user experience by displaying each error message next to the field that generated the error:

bc. #{ifErrors}
   <h1>Oops…</h1>
#{/ifErrors}
 
#{form @Application.hello()}
   <div>
      Name: <input type="text" name="name" value="${flash.name}" />
      <span class="error">#{error 'name' /}</span>
   </div>
   <div>
      Age: <input type="text" name="age" value="${flash.age}" /> 
      <span class="error">#{error 'age' /}</span>
   </div>
   <div>
      <input type="submit" value="Say hello" /> 
   </div>
#{/form}


h2. <a name="annotations">Validation annotations</a>

The annotations in the @play.data.validation@ package provide an alternative and more concise way to specify validation constraints, with an annotation that corresponds to each @Validation@ object method. To use the validation annotations, just annotate the controller method parameters:

bc. public static void hello(@Required String name, @Required @Min(0) Integer age) {
   if(validation.hasErrors()) {
       params.flash(); // add http parameters to the flash scope
       validation.keep(); // keep the errors for the next request
       index();
   }
   render(name, age);
}

h2. <a name="objects">Validating complex objects</a>

You can also use the validation annotations to easily add constraints to your model object’s properties, and then in the controller specify that all properties must be valid. Let’s rewrite the previous example using a User class.

First the @User@ class, with validation annotations on the properties:

bc. package models;
 
public class User {
    
    @Required
    public String name;
 
    @Required
    @Min(0)
    public Integer age;
}

Then the modified @hello@ action, which uses the <code>@Valid</code> annotation to specify that all of the @User@ object’s properties must be valid:

bc. public static void hello(@Valid User user) {
   if(validation.hasErrors()) {
       params.flash(); // add http parameters to the flash scope
       validation.keep(); // keep the errors for the next request
       index();
   }
   render(name, age);
}

And finally the modified form:

bc. #{ifErrors}
   <h1>Oops…</h1>
#{/ifErrors}
 
#{form @Application.hello()}
   <div>
      Name: <input type="text" name="user.name" value="${flash['user.name']}" />
      <span class="error">#{error 'user.name' /}</span>
   </div>
   <div>
      Age: <input type="text" name="user.age" value="${flash['user.age']}" /> 
      <span class="error">#{error 'user.age' /}</span>
   </div>
   <div>
      <input type="submit" value="Say hello" /> 
   </div>
#{/form}

h2. <a name="builtin">Built-in validations</a>

The @play.data.validation@ package contains several "built-in validations":validation-builtin that you can use on the @Validation@ object or with annotations.

h2. <a name="custom">Custom validation using @CheckWith</a>

Can’t find the validator you need in the @play.data.validation@ package? Write your own. You can use the generic <code>@CheckWith</code> annotation to bind your own @Check@ implementation.

For example:

bc. public class User {
    
    @Required
    @CheckWith(MyPasswordCheck.class)
    public String password;
    
    static class MyPasswordCheck extends Check {
        
        public boolean isSatisfied(Object user, Object password) {
            return notMatchPreviousPasswords(password);
        }
    }
}

The default validation error message key is @validation.invalid@. To use a different key, call @Check.setMessage@ with a message key and message parameters.

bc. static class MyPasswordCheck extends Check {
 
    public boolean isSatisfied(Object user, Object password) {
        final Date lastUsed = dateLastUsed(password);
        setMessage("validation.used", JavaExtensions.format(lastUsed));
        return lastUsed == null;
    }
}

The message look up always has the field name as the first parameter, and your message parameters as subsequent parameters. So, for the example above, you could define the message like:

bc. validation.used = &{%1$s} already used on date %2$s
user.password = Password

where @&{%1$s}@ uses the message argument with index 1 (the field name) as the message key for another message look-up, and @%2$s@ is the second message argument (the formatted date).

p(note). The message syntax - @%s@, @%s2$s@ and @&{…}@ - is explained in the section on how to "Retrieve localized messages":i18n#retrieve.


h2. <a name="customannotations">Custom annotations</a>

You can also write your own annotation validations, which is more complex but makes your model code cleaner and allows you to introduce validator parameters.

For example, suppose we want a less restrictive version of the "@URL":validation-builtin#url validation, so we can allow URLs with any scheme such as a @file://@ URL, and with a parameter that lets us specify exactly which schemes are allowed.

First, we write a custom validation annotation, with a parameter for overriding the default message:

bc. import net.sf.oval.configuration.annotation.Constraint;
import java.lang.annotation.*;
 
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.FIELD, ElementType.PARAMETER})
@Constraint(checkWith = URICheck.class)
public @interface URI {
    String message() default URICheck.message;
}

This annotation refers to an implementation of @net.sf.oval.configuration.annotation.AbstractAnnotationCheck@.

bc. public class URICheck extends AbstractAnnotationCheck<URI> {
 
    /** Error message key. */
    public final static String message = "validation.uri";
 
    /** URI schemes allowed by validation. */
    private List<String> schemes;
 
    @Override
    public void configure(URI uri) {
        setMessage(uri.message());
        this.schemes = Arrays.asList(uri.schemes());
    }
 
    /**
     * Add the URI schemes to the message variables so they can be included
     * in the error message.
     */
    @Override
    public Map<String, String> createMessageVariables() {
        final Map<String, String> variables = new TreeMap<String, String>();
        variables.put("2", JavaExtensions.join(schemes, ", "));
        return variables;
    }
 
    @Override
    public boolean isSatisfied(Object validatedObject, Object value,
        OValContext context, Validator validator) throws OValException {
 
        requireMessageVariablesRecreation();
        try {
            final java.net.URI uri = new java.net.URI(value.toString());
            final boolean schemeValid = schemes.contains(uri.getScheme());
            return schemes.size() == 0 || schemeValid;
        } catch (URISyntaxException e) {
            return false;
        }
    }
}

The @isSatisfied@ method calls @requireMessageVariablesRecreation()@ to instruct OVal to call @createMessageVariables()@ before rendering the message. This returns an ordered map of variables that are passed to the message formatter. The map keys are not used; the @"2"@ in this example indicates the message parameter index. As before, the first parameter is the field name.

To use this use the annotation on a model property.

bc. public class User {
    
    @URI(message = "validation.uri.schemes", schemes = {"http", "https"})
    public String profile;
}

We can define the messages like this:

bc. validation.uri = Not a valid URI
validation.uri.schemes = &{%1$s} is not a valid URI - allowed schemes are %2$s



p(note). **Continuing the discussion**
 
The last layer of a Play application: %(next)"Domain object model":model%.
