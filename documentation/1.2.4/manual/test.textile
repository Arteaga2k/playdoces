h1. Pruebe su aplicación

Una buena forma de hacer aplicaciones robustas es crear suites de pruebas automáticas. Permite trabajar de una forma muy ágil.

Las pruebas de Play se construyen usando "JUnit 4":http://www.junit.org/ ó "JUnit 4":http://www.junit.org/ dependiendo de lo que se pretenda probar.

h2. <a name="writing">Escribir pruebas</a>

Hay que crear las pruebas en el directorio @test/@. Esta carpeta sólo se añadirá al path de fuentes cuando la aplicación se ejecute en modo @test@. Pueden escribirse tres clases de pruebas.

h3. Pruebas unitarias

Se escriben usando JUnit. En esta clase de pruebas puede probarse el modelo de la aplicación (incluyendo algunas utilidades).

Este es un ejemplod de una prueba unitaria:

bc.. import play.test.*;
import org.junit.*;
 
public class MyTest extends UnitTest {
     
    @Test
    public void aTest() {
        assertEquals(2, 1 + 1); // Una cosa que es realmente importante probar
    }
 
    @Test
    public void testUsers() {
        assertEquals(3, Users.count()); 
    }
}

h3. Pruebas funcionales

También se usa JUnit. En esta clase de pruebas puede probarse la aplicación accediendo directamente a los objetos controlador.

Este es un ejemplo de una prueba funcional:


bc.. import play.test.*;
import play.mvc.*;
import play.mvc.Http.*;
import org.junit.*;
 
public class ApplicationTest extends FunctionalTest {
     
    @Test
    public void testTheHomePage() {
        Response response = GET("/");
        assertStatus(200, response);
    }
     
}

Con el método @renderArgs()@, también se puede dirigir el acceso a los argumentos que se pasen a la vista, en vez de tener que hacer assertions sobre la respuesta en sí misma. Por ejemplo:

bc. @Test
public void testUserIsFoundAndPassedToView() {
    Response response = POST("/user/find?name=mark&dob=18011977")
    assertThat(renderArgs("user"), is(notNullValue());
    User user = (User) renderArgs("user");
    assertThat(user.name, is("mark"));
}

h3. Pruebas Selenium

Las pruebas de aceptación se escriben usando Selenium. Aquí se puede probar la aplicación ejecutándola en un visualizador automatizado.

Las pruebas Selenium se escriben usando tablas HTML. Puede usarse esta sintaxis nativa o mediante la tag @#{selenium /}@.

Ejemplo de prueba Selenium:

bc.. #{selenium 'Test security'}
 
    // Intento de logarse en el área de administración
    clearSession()
    open('/admin')
    assertTextPresent('Login')
    type('login', 'admin')
    type('password', 'secret')
    clickAndWait('signin')
 
    // Verificar que el usuario se ha logado correctamente
    assertText('success', 'Welcom admin!')
 
#{/selenium}

p. Como las pruebas de Selenium se ejecutan dentro del navegador, hay que utilizar extensiones de Selenium para acceder a los mensajes enviados por el mail simulado y a los valores tipo String colocados en la Play Cache.

Este es un ejemplo de acceso al último email enviado a una cuenta específica:


bc.. #{selenium 'Test email sending'}
 
    // Abrir formulario email y enviar un email a to boron@localhost
    open('/sendEmail')
    assertTextPresent('Email form')
    type('To', 'boron@localhost')
    type('Subject', 'Berillium Subject')
    clickAndWait('send')
 	
	// Extraer el último email enviado a boron@localhost en una variable
        // JavaScript de nombre email
	storeLastReceivedEmailBy('boron@localhost', 'email')
	// Extraer la línea del asunto de la variable email a una
        // variable llamada subject
	store('javascript{/Subject:\s+(.*)/.exec(storedVars["email"])[1]}', 'subject')
	// Probar el contenido de la variable subject
	assertEquals('Berillium Subject', '$[subject]')
 
#{/selenium}

p. Este es un ejemplo de acceder a una cadena String guardada en la Play Cache (por ejemplo, la respuesta correcta a un CAPTCHA):


bc.. #{selenium 'Get string from cache'}
 
	open('/register')
	assertTextPresent('Registration form')
	type('Email', 'my@email.com')
	type('Password', 'secretpass')
	type('Password2', 'secretpass')
	// .. Rellenar aqui el formulario de registro ...
 
	// Obtener el valor de la variable magicKey de la cache
	// (cargarlo en la respuesta al CAPTCHA de la aplicacion)
	storeCacheEntry('magicKey', 'captchaAnswer')
	// Escribirlo en el formulario
	type('Answer', '$[captchaAnswer]')
 
    clickAndWait('register')
 
#{/selenium}

h2. <a name="fixtures">Accesorios (Fixtures)</a>

Cuando se hacen pruebas, hay que tener datos estables para la aplicación. Lo más sencillo para esto es resetear la base de datos antes de cada prueba.

La clase @play.test.Fixtures@ ayuda a manipular la base de datos y a inyectar datos de prueba. Se suele usar en el método <code>@Before</code> de una prueba JUnit.

bc. @Before
public void setUp() {
    Fixtures.deleteAll();
}

Para importar los datos, es más sencillo definirlos en un fichero YAML que el helper de Fixtures pueda importar automáticamente.

bc.. # Datos de prueba
 
Company(google):
   name:    Google
 
Company(zen):
   name:    Zenexity
 
User(guillaume):
   name:    guillaume
   company: zen

p. Y luego: 

bc. @Before
public void setUp() {
    Fixtures.deleteAll();
    Fixtures.loadModels("data.yml");
}

p(note). Más detalles sobre Play y YAML en la "página YAML del manual":yaml.

Para las pruebas Selenium puede usarse el tag @#{fixture /}@

bc. #{fixture delete:'all', load:'data.yml' /}
 
#{selenium}
    
    // Escribe aquí tu prueba
 
#{/selenium}

A veces es conveniente dividir los datos en varios ficheros YAML. Pueden cargarse accesorios a partir de múltiples ficheros a la vez:

bc. Fixtures.loadModels("users.yml", "roles.yml", "permissions.yml");

y para las pruebas Selenium:

bc. #{fixture delete:'all', load:['users.yml', 'roles.yml', 'permissions.yml'] /}

h2. <a name="running">Ejecutar las pruebas</a>

Para ejecutar las pruebas, hay que correr la aplicación en modo @test@ con el comando @play test@.

bc. # play test myApp

En este modo, Play carga automáticamente el módulo @test-runner@. Este módulo contiene un probador basado en Web, disponible en la URL: "http://localhost:9000/@tests":http://localhost:9000/@tests.

!images/test-runner!

Cuando se ejecuta una prueba, el resultado se salva en el directorio @/test-result@ de la aplicación.

En la página del probador, cada prueba es un enlace, puede hacerse click derecho y 'Abrir en pestaña nueva' para ejeuctar directamente fuera del probador.

Si se ejecutan las prueabs de esta forma, Play arrancará con un marco especial @test@. Así que pueden definirse configuraciones especiales en el fichero @application.conf@.

Si queremos tener diferentes configuraciones de pruebas, podemos usar IDs del marco que coincidan con el patrón @test-?.*@ (p. ej.: @test-special@).

Si usamos un ID del marco distinto de la opción por defecto @test@, hay que asegurarse de que TODA la configuración de pruebas en @application.conf@ está disponible con ese ID de marco. Para lanzar pruebas con un ID especial: @play test --%test-your-special-id@

Por ejemplo:

bc. %test.db=mem
%test.jpa.ddl=create-drop

h2. <a name="continuous">Integración continua y ejecución automática de pruebas</a>

El comando @auto-test@ hace lo mismo que el @test@, pero lanza automáticamente un navegador, ejecuta todas las pruebas, y se para.

Es un comando útil cuando se quiere configurar un sistema de integración continua.

Tras la ejecución, se salvan todos los resultados en el directorio @/test-result@. Además, este directorio contiene un fichero (bien @result.fail@ o @result.passed@) que contiene el resultado final. Este directorio contiene todos los logs en el fichero @application.log@.

De modo que configurar un sistema de integración continua para probar la aplicación, podría hacerse:

* Checkout de la última versión de la aplicación
* Ejecutar @play auto-test@
* Esperar al final del proceso
* Comprobar el fichero @result.passed@ o @result.failed@ en el directorio @/test-result@

Ejecuta estos pasos en una tarea del CRON y ya está.

Puede cambiarse el modo de compatiblidad del navegador para utilizar uno sin cabeza con este parámetro "headlessBrowser":configuration#headlessBrowser.

p(note). **Próximos pasos**
 
Seguimos con %(next)"Guía de Seguridad":security%.
