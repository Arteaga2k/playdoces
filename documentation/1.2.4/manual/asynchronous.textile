h1. Programación asíncrona con HTTP

Esta sección explica cómo enfrentarse a la asincronía en una aplicación Play para obtener las aplicaciones típicas __long-polling, streaming__ y otras aplicaciones "Comet-style":http://en.wikipedia.org/wiki/Comet_(programming%29 que pueden escalar hasta miles de conexiones concurrentes.

h2. Suspensión de solicitudes HTTP

Play está pensada para trabajar con requests muy cortas. Usa una pool de hilos (__thread pool__) de longitud fija para procesar las requests encoladas por el conector HTTP. Para obtener resultados óptimos, la pool de hilos ha de ser tan pequeña como sea posible. Normalmente usamos el valor óptimo de @number of processors + 1@ como valor por defecto del tamaño de la pool.

Esto significa que si el tiempo de proceso de una request es muy largo (por ejemplo, esperando a un cálculo muy largo) bloqueará la pool y penalizará la responsividad de la aplicación. Por supuesto, se podrían añadir más hilos a la pool, pero esto implica recursos desperdiciados y además, el tamaño de la pool nunca será infinito.

Sea una aplicación de char en la que los navegadores envían una request HTTP bloqueante y esperan que se muestre un mensaje nuevo. Estas requests pueden ser muy largas (normalmente varioa segundos) y bloquean la pool de hilos. Si tu plan es permitir que se conecten simultáneamente 100 usuarios a la aplicación de chat, necesitarás una pool de al menos 100 hilos. Vale, esto es factible. Pero, ¿y si queremos 1000 usuarios? ¿o 10.000?

Para resolver estos casos de uso, Play permite suspender temporalmente una request. La request HTTP seguirá conectada, pero la ejecución de la request se sacará de la pool y se intentará de nuevo más tarde. Puedes decirle a Play que intente la request después de un retraso prefijado, o esperar a que el valor de una @Promise@ esté disponible.

p(note). **Nota**. Puedes ver un ejemplo real en @samples-and-tests/chat@.

Por ejemplo, esta acción lanza un job muy largo y espera a su terminación antes de devolver los resultados a la response HTTP.

bc. public static void generatePDF(Long reportId) {
    Promise<InputStream> pdf = new ReportAsPDFJob(report).now();
    InputStream pdfStream = await(pdf);
    renderBinary(pdfStream);
}

Aquí usamos @await(…)@ para decirle a Play que suspenda la request hasta que se redima el valor de @Promise<InputStream>@. 

h3. Reanudaciones (__continuations__)

Com el marco tiene que recuperar el hilo que estabas usando para servir otras requests, tiene que suspender tu código. En la versión anterior de Play, el equivalente del @await(…)@ era @waitFor(…)@, que suspendía tu acción, y después la llamava desde el principio. 

Para que sea más fácil enfrentarse al código asíncrono hemos introducido las reanudaciones (__continuations__). Las reanudaciones permiten que se suspenda tu código y se reanude transparentemente. Así puedes escribir tu código de forma muy imperativa:

bc. public static void computeSomething() {
    Promise<String> delayedResult = veryLongComputation(…);
    String result = await(delayedResult);
    render(result);
}

De hecho aquí, tu código se ejecutará en dos pasos, en dos hilos diferentes. Pero como ver, esto es transparente para el código de tu apliación.

Mediante el uso de @await(…)@ y las reanudaciones, podrías escribir un bucle: 

bc. public static void loopWithoutBlocking() {
    for(int i=0; i<=10; i++) { 
         Logger.info(i);
         await("1s");
    }
    renderText("Fin del bucle");
}

Incluso cuando se usa un sólo hilo para procesar las requests, que es lo normal en modo desarrollo, Play es capaz de ejecutar concurrentemente estos bucles para varias requests al mismo tiempo.

Un ejemplo más realista es recuperar de forma asíncrona contenido de URLs remotas. El ejemplo siguiente ejecuta tres solicitudes HTTP en paralelo: cada llamada al método @play.libs.WS.WSRequest.getAsync()@ ejecuta una request GET asíncrona y devuelve un @play.libs.F.Promise@. El método de acción suspende la request HTTP entrante mediante la llamada a  @await(…)@ en la combinación de las tres instancias de @Promise@. Cuando las tres llamadas remotas tienen una respuesta, otro hilo resume el proceso y genera una response.

bc. public class AsyncTest extends Controller {
  public static void remoteData() {
    F.Promise<WS.HttpResponse> r1 = WS.url("http://example.org/1").getAsync();
    F.Promise<WS.HttpResponse> r2 = WS.url("http://example.org/2").getAsync();
    F.Promise<WS.HttpResponse> r3 = WS.url("http://example.org/3").getAsync();
    F.Promise<List<WS.HttpResponse>> promises = F.Promise.waitAll(r1, r2, r3);
    // Suspend processing here, until all three remote calls are complete.
    List<WS.HttpResponse> httpResponses = await(promises);
    render(httpResponses);
  }
}


h3. Retrollamadas (__Callbacks__)

Una forma diferente de implementar el ejemplo anterior de tres llamadas remotas asíncronas es usar una retrollamada. Eta vez, la llamada a @await(…)@ incluye una implementación de @play.libs.F.Action@, que es una retrollamada que se ejecuta cuando las @promises@ han terminado.

bc. public class AsyncTest extends Controller {
  public static void remoteData() {
    F.Promise<WS.HttpResponse> r1 = WS.url("http://example.org/1").getAsync();
    F.Promise<WS.HttpResponse> r2 = WS.url("http://example.org/2").getAsync();
    F.Promise<WS.HttpResponse> r3 = WS.url("http://example.org/3").getAsync();
    F.Promise<List<WS.HttpResponse>> promises = F.Promise.waitAll(r1, r2, r3);
    // Suspender el proceso aquí hasta que las tres llamadas remotas estén completas.
    await(promises, new F.Action<List<WS.HttpResponse>>() {
      public void invoke(List<WS.HttpResponse> httpResponses) {
        render(httpResponses);
      }
    });
  }
}


h2. Streaming de respuestas HTTP

Una vez que ya puedes hacer bucles sin bloquear la request, puede que quieras enviar los datos al navegador tan pronto como tengas alguna parte de los resultados disponibles. Este es el punto del tipo de respuesta HTTP @Content-Type:Chunked@. Te permite enviar la response HTTP varias veces dividiéndola en varios trozos. El navegador recibirá los trozos tan pronto como se publiquen.

Mediante el uso de @await(…)@ y las reanudaciones, puedes hacerlo de esta forma:

bc. public static void generateLargeCSV() {
    CSVGenerator generator = new CSVGenerator();
    response.contentType = "text/csv";
    while(generator.hasMoreData()) {
          String someCsvData = await(generator.nextDataChunk());
          response.writeChunk(someCsvData);
    }
}

Incluso si la generación de CSV tarda una hora, Play es capaz de procesar simultáneamente varias request usando un solo hilo, devolviendo los datos generados al cliente tan pronto como están disponibles.


h2. Uso de WebSockets

Los WebSockets son una forma de abrir un canal de comunicaciones bidireccional entre un navegador y tu aplicación. En el lado del navegador, se abre un socket utilizando urls del tipo "ws://":

bc. new Socket("ws://localhost:9000/helloSocket?name=Guillaume")

En el lado de Play se declara una ruta WS:

bc. WS   /helloSocket            MyWebSocket.hello

@MyWebSocket@ es un @WebSocketController@. Un controlador de WebSocket es como el controlador estándar HTTP pero gestiona diferentes conceptos.

* Tiene un objeto request, pero no un objeto response.
* Tiene acceso a la sesión, pero en sólo lectura.
* No tiene @renderArgs@, @routeArgs@ ni flash scope.
* Puede leer parámetros sólo a partir del patrón de la ruta o desde la cadena QueryString.
* Tiene dos canales de comunicación: inbound (__entrada__) y outbound (__salida__).

Cuando el cliente se conecta al socket @ws://localhost:9000/helloSocket@, Play invoca al método de acción @MyWebSocket.hello@. Cuando el método termina, se cierra el socket.

Así que un ejemplo muy básico de socket podría ser:

bc. public class MyWebSocket extends WebSocketController {
    public static void hello(String name) {
        outbound.send("¡Hola %s!", name);
    }
}

Aquí cuando el ciente se conecta al socket, recibe el mensaje 'Hello Guillaume', y luego Play cierra el socket.

Normalmente, no querremos cerrar el socket inmediatamente, pero es fácil lograrlo con @await(…)@ y las reanudaciones.

Por ejemplo, un servidor básico de eco:

bc. public class MyWebSocket extends WebSocketController {
    public static void echo() {
        while(inbound.isOpen()) {
             WebSocketEvent e = await(inbound.nextEvent());
             if(e instanceof WebSocketFrame) {
                  WebSocketFrame frame = (WebSocketFrame)e;
                  if(!e.isBinary) {
                      if(frame.textData.equals("quit")) {
                          outbound.send("Bye!");
                          disconnect();
                      } else {
                          outbound.send("Echo: %s", frame.textData);
                      }
                  }
             }
             if(e instanceof WebSocketClose) {
                 Logger.info("Socket closed!");
             }
        }
    }
}

En el ejemplo anterior, hay un batiburrillo de 'if' anidados y 'cast', tedioso de escribir y propenso a errores. Y es aquí donde Java apesta. Incluso en el caso sencillo que vemos aquí no es fácil de manejar. Y para casos más complicados conde pueden combinarse varios streams, y tener más tipos de eventos, se vuelve una pesadilla.

Por eso hemos introducir una comparación de patrones básica en Java en la biblioteca "play.libs.F":libs#FunctionalprogrammingwithJava.

Así que podemos escribir el ejemplo del eco de esta forma:

bc. public static void echo() {
    while(inbound.isOpen()) {
         WebSocketEvent e = await(inbound.nextEvent());
         for(String quit: TextFrame.and(Equals("quit")).match(e)) {
             outbound.send("Bye!");
             disconnect();
         }
         for(String msg: TextFrame.match(e)) {
             outbound.send("Echo: %s", frame.textData);
         }
         for(WebSocketClose closed: SocketClosed.match(e)) {
             Logger.info("Socket closed!");
         }
    }
}

p(note). **Continuando la discusión**
 
Ahora, haremos %(next)"Requests Ajax":ajax%.
