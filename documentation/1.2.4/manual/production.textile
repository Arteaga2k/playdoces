h1. Pon tu aplicación en producción

Aquí te damos algunos tips para optimizar tu aplicación en un ambiente productivo.

h2. <a name="application">application.conf</a>

Antes que nada, la mejor forma de configurar la aplicación para modo productivo es dar un ID específico para el framework de producción. Escojamos @production@ como un ejemplo. Visita "administra application.conf in en diferentes ambientes":ids para ver cómo.

h3. Establecer el framework en modo de producción

bc. %production.application.mode=prod

En este modo, el framework pre compilará todos los archivos fuente java y las plantillas. Si un error es encontrado en este paso, la aplicación no iniciará. Habrá que reiniciar el framework para tomar los cambios hechos al código fuente.

h3. Definir una base de datos real

Si usaste una base de datos de desarrollo (ya sea @db=mem@ o @db=fs@), deberías configurar un motor de base de datos más robusto:

bc. %production.db.url=jdbc:mysql://localhost/prod
%production.db.driver=com.mysql.jdbc.Driver
%production.db.user=root
%production.db.pass=1515312

h3. Deshabilita la actualización automática del esquema en JPA

Si usaste la actualización automática del esquema de base de datos que proveé Hibernate, debes deshabilitar esta característica en el ambiente de producción.

Para el servidor de producción, generalmente es mala idea dejar que Hibernate ejecute automáticamente ALTER's en la base de datos, tanto en el esquema como en los datos…

El despliegue inicial tal vez es un caso aparte, Si deseas que Hibernate genere una base de datos límpia en el ambiente productivo tan sólo especifica:

bc. %production.jpa.ddl=create

h3. Definir una llave secreta segura

La llave secreta de Play es usada para asegurar funciones criptográficas, como la firma de la sesión. Tu aplicación debe conservar esta llave muy bien guardada.

bc. %production.application.secret=c12d1c59af499d20f4955d07255ed8ea333

Puedes usar el comando @play secret@ para generar una nueva llave aleatoria segura (por lo menos en un Sistema Operativo ‘real’). Si planeas distribuir la aplicación en muchos servidores recuerda que debes usar la **misma llave** para todas las instancinas de la aplicación.

h2. <a name="logging">Configuración del Log de bitácora</a>

Para el ambiente productivo, es una buena idea usar archivos de log continuos. No escribir el log en la consola, ya que estos serán dirigidos al archivo @logs/system.out@ y crecerá sin medida.

Crea un archivo @log4j.properties@ personalizado en el directorio @conf/@:

bc. log4j.rootLogger=ERROR, Rolling
 
log4j.logger.play=INFO
 
# Archivos continuos
log4j.appender.Rolling=org.apache.log4j.RollingFileAppender
log4j.appender.Rolling.File=application.log
log4j.appender.Rolling.MaxFileSize=1MB
log4j.appender.Rolling.MaxBackupIndex=100
log4j.appender.Rolling.layout=org.apache.log4j.PatternLayout
log4j.appender.Rolling.layout.ConversionPattern=%d{ABSOLUTE} %-5p ~ %m%n

h2. <a name="server">Servidor HTTP frontal</a>

Puedes desplegar fácilmente tu aplicación como un servidor independiente configurando el puerto HTTP @80@:

bc. %production.http.port=80

Pero si planeas desplegar distintas aplicaciones en el mismo servidor o balancear la carga de distintas instancias de la aplicacion para mayor escalabilidad y tolerancia a errores, entonces puedes usar un servidor HTTP frontal.

**Nota: Un servidor HTTP frontal nunca te datá mejor desempeño que usando el servidor HTTP de Play directamente**

h3. Configuración de lighttpd

Este ejemplo muestra cómo configurar "lighttpd":http://www.lighttpd.net/ como servidor web frontal. Nota que puedes hacer lo mismo con Apache, pero si sólo necesitas alojamiento virtual o balanceo de cargas, lighttpd es una muy buena elección y mucho más fácil de configurar.

El archivo @/etc/lighttpd/lighttpd.conf@ debe definir parámetros como los siguientes:

bc. server.modules = (
      "mod_access",
      "mod_proxy",
      "mod_accesslog" 
)
…
$HTTP["host"] =~ "www.myapp.com" {
    proxy.balance = "round-robin" proxy.server = ( "/" =>
        ( ( "host" => "127.0.0.1", "port" => 9000 ) ) )
}
 
$HTTP["host"] =~ "www.loadbalancedapp.com" {
    proxy.balance = "round-robin" proxy.server = ( "/" => ( 
          ( "host" => "127.0.0.1", "port" => 9000 ), 
          ( "host" => "127.0.0.1", "port" => 9001 ) ) 
    )
}

h3. Configuración de Apache

El siguiente ejemplo muestra una comfiguración simple usando el "servidor httpd de Apache":http://httpd.apache.org/ puesto como servidor frontal de una configuración de Play estándar.

bc. LoadModule proxy_module modules/mod_proxy.so
…
<VirtualHost *:80>
  ProxyPreserveHost On
  ServerName www.loadbalancedapp.com
  ProxyPass / http://127.0.0.1:9000/
  ProxyPassReverse / http://127.0.0.1:9000/
</VirtualHost>

h3. Apache como proxy frontal que permite un despligue transparente de la aplicación

La idea básica es correr dos instancias de Play dentro de la aplicación web y permite al proxy frontal balancear la carga entre ellos. En caso de que alguno no esté disponible, se dirigirán todas las solicitudes HTTP a la instancia disponible.

Ahora iniciemos la misma aplicación de Play dos veces, una en el puerto 9999 y otra en el puerto 9998.

Haz una copia de la aplicación y edita el archivo @application.conf@ dentro del directorio @conf@ para cambiar los números de puerto.

Para cada directorio de la aplicación web:

bc. play start mysuperwebapp

Ahora vamos a examinar la configuración de nuestro servidor web de Apache para tener un balanceador de carga:

En Apache, debes tener la siguiente configuración:

bc. <VirtualHost mysuperwebapp.com:80>
  ServerName mysuperwebapp.com
  <Location /balancer-manager>
    SetHandler balancer-manager
    Order Deny,Allow
    Deny from all
    Allow from .mysuperwebapp.com
  </Location>
  <Proxy balancer://mycluster>
    BalancerMember http://localhost:9999
    BalancerMember http://localhost:9998 status=+H
  </Proxy>
  <Proxy *>
    Order Allow,Deny
    Allow From All
  </Proxy>
  ProxyPreserveHost On
  ProxyPass /balancer-manager !
  ProxyPass / balancer://mycluster/
  ProxyPassReverse / http://localhost:9999/
  ProxyPassReverse / http://localhost:9998/
</VirtualHost>

La parte importante es @balancer://mycluster@. Esto define un balanceador de carga. El parámetro @+H@ significa que la segunda aplicación de Play está en modo de espera, pero puedes configurarlo para balanceo de cargas.

Cada vez que quieras actualizar @mysuperwebapp@, esto es lo que necesitas hacer:

bc. play stop mysuperwebapp1

El balanceador de cargas dirige todo a @mysuperwebapp2@ mientras actualizas @mysuperwebapp1@. Una vez que estés listo:

bc. play start mysuperwebapp1

Ahora puedes actualizar @mysuperwebapp2@ con seguridad.

Apache además provee una forma de ver el estado de tu cluster. Simplemente dirige tu navegador a @/balancer-manager@ para ver el estado actual de tu cluster.

Debido a que Play usa un __modelo sin estado__ no necesitas administrar las sesiones entre las aplicaciones. Así puedes fácilmente esclar mas de 2 instancias de Play.

h3. Configuración avanzada del proxy

Cuando usas un servidor frontal HTTP las direcciones del __request__ son vistas como vienen del servidor HTTP. En una configuración usual donde tienes aplicaciones de Play y el proxy corriendo en la misma máquina, la aplicación de Play ve los __request__ que vienen de 127.0.0.1.

Los servidores proxy también pueden agregar un encabezado HTTP específico al __request__ para decirle a la aplicación enmascarada de dónde vino el __request__. La mayoría de los servidores web van a agregar un encabezado @X-Forwarded-For@ con la dirección IP del cliente remoto en el primer argumento. Si tu habilitas la opción de direccionamiento en "Configuración de XForwardedSupport":configuration#XForwardedSupport, Play cambiará el parámetro @request.remoteAddress@ de la dirección IP del proxy a la dirección IP del cliente remoto. Debes listar las direcciones IP de tus servidores proxy para que funcione está opción.

Sin embargo, el encabezado del host permanece intacto, sigue estando configurado por el proxy. Si usas Apache 2.x puedes agregar esta directiva de la siguiente forma:

bc. ProxyPreserveHost on

El encabezado host será el mismo encabezado que mandó el cliente. Combinando estas dos técnicas, tu aplicación va a parecer que está directamente expuesta en internet.

h2. <a name="https">Configuración HTTPS</a>

El servidor HTTP interno soporta el protocolo HTTPS, que también se puede usar en producción. Soporta administración de certificados ya sea de la forma clásica de Java **keystore** o simplemente configurando los archivos @cert@ y @key@. Para iniciar el conector HTTPS para tu aplicación sólo configura @https.port@ en tu archivo @application.conf@:

bc. http.port=9000
https.port=9443

Debes coloar los certificados en el directorio @conf@. Play soporta certificados X509 y de tipo __keystore__. Los certificados X509 deben ser llamados de la siguiente forma:
*host.cert* para el certificado y *host.key* para la llave. Si estás usando __keystore__ entonces, por defecto debe ser llamado *certificate.jks*.

Si estás usando certificados X509, entonces pudes configurar los siguientes parámetros en tu archivo @application.conf@:

bc. # X509 certificates
certificate.key.file=conf/host.key
certificate.file=conf/host.cert
# En caso de que tu archivo llave esté protegido por password:
certificate.password=secret
trustmanager.algorithm=JKS

Si estás usando un __keystore__:

bc. keystore.algorithm=JKS
keystore.password=secret
keystore.file=conf/certificate.jks

Nota que la configuración mencionada son los valores por defecto.

Puedes generar certificados auto firmados usando la herramienta *openssl*:

bc. openssl genrsa 1024 > host.key
openssl req -new -x509 -nodes -sha1 -days 365 -key host.key > host.cert

Si estás usando el mecanismo de __keystore__ de Java, entonces las siguientes propiedades pueden ser configuradas en tu archivo @application.conf@: 

bc. # Keystore 
ssl.KeyManagerFactory.algorithm=SunX509
trustmanager.algorithm=JKS
keystore.password=secret
keystore.file=certificate.jks

Los valores mencionados también son por defecto.

h2. <a name="nopython">Desplegando sin usar Python</a>

Python es instalado por defecto en la mayoría de los equipos Unix, y Play incluye una versión de Windows. Sin embargo puede haber casos en los que necesitas desplegar la aplicación en un servidor que no tiene ningún ejecutable de Python.

Para eso, Las aplicaciones de Play proveen un archivo de Ant @build.xml@ con funcionalidad limitada

Desde el directorio de la aplicación, puedes iniciar el servidor usando:

bc. ant start -Dplay.path=/path/to/playdirectory

Precaución: Usando el comando @play@ la salida se direcciona a @System.out@; sin embargo si se usa Ant no está disponible la salida estándar. Es necesario proveer un archivo de configuración Log4j donde se especifique una salida a archivo.

Para detener el servidor:

bc. ant stop -Dplay.path=/path/to/playdirectory

También puedes especificar la ruta al framework de Play en una variable de entorno o directamente en el archivo @build.xml@ de la aplicación.

p(note). **Continúa la discusión**

Siguiente: %(next)"Opciones de puesta en producción":deployment%.
