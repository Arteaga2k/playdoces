p(note). Esta página todavía no ha sido traducida al castellano. Si quieres colaborar con nosotros y ayudar con la traducción lee nuestra "guía para colaborar con la traducción de play":translation.

h1. El modelo de objetos de dominio

El modelo tiene una posición central en una aplicación Play. Es la representación específica al dominio de la información sobre la que la aplicación opera.

Martin Fowler lo define como:

bq. Responsable de representar los conceptos del negocio, información sobre la situación del negocio, y las reglas de negocio. El estado que refleja la situación del negocio se controla y se usa aquí, aunque los detalles técnicos de su almacenaje se delegan a la infraestructura. Esta capa es el corazón del software empresarial.
Un antipatrón común en Java es conservar el modelo como un conjunto de Java Beans simples y poner la lógica de la aplicación en una capa de "servicios" que operan sobre los objetos del modelo.
"service" layer which operates on the model objects.

Martin Fowler ha bautizado a este antipatrón como "El modelo de objetos anémico" "Anemic object model": http://www.martinfowler.com/bliki/AnemicDomainModel.html: 

bq. El síntoma básico de que el modelo de dominio es Anémico a primera vista es que se parece al objeto real. Hay objetos, muchos de ellos nombrados según los nombres del espacio de dominio, y esos objetos están conectados con las ricas relaciones y estructura que los objetos reales tienen en el dominio. El problema viene cuando miras al comportamiento, y te das cuenta de que apenas existe en estos objetos, lo que los convierte en poco más que sacos de getters y setters. Además, estos modelos vienen con reglas de diseño que dicen que no puedes poner lógica del dominio en los objetos del dominio. Para ello están una serie de objetos de servicio que capturan toda la lógica del ominio. Estos servicios residen encima del modelo de capture all the domain logic. These services live on top of the domain model and use the domain model for data.

El horror fundamental de este antipatrón es que va completamente en contra de la idea básica del diseño orientado a objetos, que es combinar datos y proceso juntos. El modelo de dominio anémico es realmente un diseño de estilo procedimiental, exactamente la clase de cosa contra la que los geeks de los objetos como yo mismo (y Eric) hemos estado luchando desde nuestros días de juventud en Smalltalk. Y lo que es peor, mucha gente cree que los objetos anémicos son objetos reales y por tanto, pierden por completo la idea de lo que va todo esto del diseño orientado a objetos.


h2. <a name="properties">Properties simulation</a>

Si echas un vistazo a las aplicaciones ejemplo de Play, verás a menudo que las clases declaran variables públicas. Si eres un desarrollador Java con alguna experiencia, te estarán sonando campanas y alarmas de todos los colores a la simple vista de una variable pública. En Java (como en otros lenguajes orientados a objetos), las best practices dicen que hay que hacer todos los campos privados y proporcionar métodos de acceso y de modificación. Esto es así para fomentar la encapsulación, un concepto crítico en el diseño orientado a objetos.

Java no incluye un sistema de definición de propiedades real. Usa una convención llamada Java Beans: una propiedad de un objeto Java se define por una pareja de métodos getXxx/setXxx. Si la propiedad es de sólo lectura, entonces sólo habrá un getter.

Aunque el sistema funciona bien, es muy tedioso de escribir. Para cada propiedad tienes que declarar una variable privada y escribir dos métodos. De esta forma, la mayoría de los getters y setters son siempre iguales:

bc. private String name;
 
public String getName() {
    return name;
}
 
public void setName(String value) {
    name = value;
}

La parte Modelo de la Play framework automáticamente genera este patrón manteniendo tu código limpio. Efectivamente, todas las variables públicas se convierten en propiedades de instancia. La convención es que cualquier campo  **public**, **non-static**, **non-final** de una clase se ve como una propiedad.

Por ejemplo, cuando defines una clase como esta:

bc. public class Product {
 
    public String name;
    public Integer price;
}

La clase cargada será:

bc. public class Product {
 
    public String name;
    public Integer price;
 
    public String getName() {
        return name;
    }
 
    public void setName(String name) {
        this.name = name;
    }
 
    public Integer getPrice() {
        return price;
    }
 
    public void setPrice(Integer price) {
        this.price = price;
    }
}

Así que cuando quieras acceder a una propiedad basta que escribas:

bc. product.name = "My product";
product.price = 58;

Lo que en tiempo de carga se traduce a:

bc. product.setName("My product");
product.setPrice(58);

p(note). **¡Atención!**
 
No puedes usar directamente los métodos getter y setter para acceder a las propiedades si delegas en la generación automática. Estos métodos se generan en tiempo de ejecución, así que si los referencias en el código, el compilador no los encontrará y arrojará un error.

Por supuesto, puedes definir tus propios métodos getter y setter. Si existen, Play los usará.

Así que para proteger el valor de la propiedad price de la clase Product, puedes escribir:

bc. public class Product {
 
    public String name;
    public Integer price;
 
    public void setPrice(Integer price) {
        if (price < 0) {
            throw new IllegalArgumentException("¡El precio no puede ser negativo!");
        }
        this.price = price;
    }
}

Luego si intentas cargar un valor negativo aparecerá una excepción:

bc. product.price = -10: // Oops! IllegalArgumentException

Play siempre usará el getter o setter definido si existe. Veamos este código:

bc. @Entity
public class Data extends Model {
 
   @Required
   public String value;
   public Integer anotherValue;
 
   public Integer getAnotherValue() {
       if(anotherValue == null) {
           return 0;
       }
       return anotherValue;
   }
 
   public void setAnotherValue(Integer value) {
       if(value == null) {
           this.anotherValue = null;
       } else {
           this.anotherValue = value * 2;
       }
   }
 
   public String toString() {
       return value + " - " + anotherValue;
   }
 
}

Desde otra claes, puedes intentar estas assertions:

bc. Data data = new Data();
data.anotherValue = null;
assert data.anotherValue == 0;
data.anotherValue = 4
assert data.anotherValue == 8;

Sí, funciona. Y porque la clase mejorada sigue la convención Java Beans, cuando usas tu objeto con una librería que espera un JavaBean, funcionará perfectamente.


h2. <a name="database">Configura una base de datos para persistir tu modelo</a>

La mayoría de las veces necesitarás salvar los datos del objeto del modelo permanentemente. Lo más natural es salvarlos a una base de datos.

Durante el desarrollo puedes configurar rápidamente una base de datos integrada, bien en memoria, o salvada en un subdirectorio dentro de la aplicación, usando la "db configuration":configuration#db.

La distribución de Play incluye drivers JDBC para H2 y MySQL en el directorio @$PLAY_HOME/framework/lib/@. Si quieres usar una base de datos PostreSQL u Oracle, por ejemplo, tienes que añadir la librería del driver JDBC en ese directorio o en el directorio @lib/@ de la aplicación.

Para conectar a cualquier base de datos que implemente JDBC. Añade la librería del driver y define las propiedades JDBC "db.url":configuration#db.url, "db.driver":configuration#db.driver, "db.user":configuration#db.user y  "db.pass":configuration#db.pass:

bc. db.url=jdbc:mysql://localhost/test
db.driver=com.mysql.jdbc.Driver
db.user=root
db.pass=

También puedes configurar un dialecto JPA con "jpa.dialect":configuration#jpa.dialect.

Desde el código puede obtenerse una @java.sql.Connection@ a partir del @play.db.DB@ y usarlo de la forma estándar.

bc. Connection conn = DB.getConnection();
conn.createStatement().execute("select * from products");

h2. <a name="hibernate">Persiste tu modelo de objetos con Hibernate</a>

You can use Hibernate (through JPA) to persist your Java objects in the Database automatically.

When you define JPA entities by adding <code>@javax.persistence.Entity</code> annotations to any Java object, Play will automatically start a JPA entity manager.

bc. @Entity
public class Product {
 
    public String name;
    public Integer price;
}

p(note). **Warning!**
 
A common mistake is to use the Hibernate <code>@Entity</code> annotation instead of the JPA one. Remember that Play uses Hibernate through the JPA API.

You can then obtain the EntityManager from the @play.db.jpa.JPA@ object:

bc. EntityManager em = JPA.em();
em.persist(product);
em.createQuery("from Product where price > 50").getResultList();

Play provides a nice support class to help you to deal with JPA. Just extend @play.db.jpa.Model@.

bc. @Entity
public class Product extends Model {
 
    public String name;
    public Integer price;
}

And then manipulate the @Product@ object using simple methods on the @Product@ instances:

bc. Product.find("price > ?", 50).fetch();
Product product = Product.findById(2L);
product.save();
product.delete();

h2. <a name="stateless">Keep the model stateless</a>

Play is designed to operate in a ‘share nothing’ architecture. The idea is to keep the application completely stateless. By doing this you will allow your application to run on as many server nodes as needed at the same time.

What are the common traps you should avoid to keep the model stateless? **Do not store any object on the Java heap for multiple requests**

h4. When you want to keep data across multiple requests you have several choices:

# If data is small and simple enough, store it into the flash or the session scope. However these scopes are limited to about 4 KB each, and allow only String data.
# Save the data permanently into persistent storage (like a database). For example if you need to create an object with a "wizard" that spans multiple requests:
#* Initialize and persist the object into the database at the first request.
#* Save the newly-created object’s ID into the flash scope.
#* During successive requests, retrieve the object from the database using the object ID, update it, and save it again. 
# Save the data temporarily into a transient storage (such as the Cache). For example if you need to create an object with a "wizard" that spans multiple requests:
#* Initialize the object and save it into the Cache at the first request.
#* Save the newly-created object’s key into the flash scope
#* During successive requests, retrieve the object from the cache (with the correct key), update it, and save it into the cache again. 
#* At the end of the last request in the chain, save the object permanently (into the database for example)

The Cache is not a reliable storage but if you put an object in the cache you should be able to retrieve it. Depending on your requirements, the Cache can be a very good choice and a good replacement for the Java Servlet session.

p(note). **Continuing the discussion**
 
Now we’ll check how to persist the model using %(next)"JPA persistence":jpa%.
