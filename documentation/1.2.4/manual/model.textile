p(note). Esta página todavía no ha sido traducida al castellano. Si quieres colaborar con nosotros y ayudar con la traducción lee nuestra "guía para colaborar con la traducción de play":translation.

h1. El modelo de objetos de cominio

El modelo tiene una posición central en una aplicación Play. Es la representación específica al dominio de la información sobre la que la aplicación opera.

Martin Fowler lo define como:

bq. Responsable de representar los conceptos del negocio, información sobre la situación del negocio, y las reglas de negocio. El estado que refleja la situación del negocio se controla y se usa aquí, aunque los detalles técnicos de su almacenaje se delegan a la infraestructura. Esta capa es el corazón del software empresarial.
Un antipatrón común en Java es conservar el modelo como un conjunto de Java Beans simples y poner la lógica de la aplicación en una capa de "servicios" que operan sobre los objetos del modelo.
"service" layer which operates on the model objects.

Martin Fowler ha bautizado a este antipatrón como "El modelo de objetos anémico" "Anemic object model": http://www.martinfowler.com/bliki/AnemicDomainModel.html: 

bq. El síntoma básico de que el modelo de dominio es Anémico a primera vista es que se parece al objeto real. Hay objetos, muchos de ellos nombrados según los nombres del espacio de dominio, y esos objetos están conectados con las ricas relaciones y estructura que los objetos reales tienen en el dominio. El problema viene cuando miras al comportamiento, y te das cuenta de que apenas existe en estos objetos, lo que los convierte en poco más que sacos de getters y setters. Además, estos modelos vienen con reglas de diseño que dicen que no puedes poner lógica del dominio en los objetos del dominio. Para ello están una serie de objetos de servicio que capturan toda la lógica del ominio. Estos servicios residen encima del modelo de capture all the domain logic. These services live on top of the domain model and use the domain model for data.

El horror fundamental de este antipatrón es que va tan en contra de la idea básica del diseño orientado a objetos, que es combinar datos y proceso juntos. El modelo de dominio anémico es realmente un diseño de estilo procedimiental, exactamente la clase de cosa contra la que los geeks de los objetos como yo mismo (y Eric) hemos estado luchando desde nuestros días de juventud en Smalltalk. Y lo que es peor, mucha gente cree que los objetos anémicos son objetos reales y por tanto, pierden por completo la idea de lo que va todo esto del diseño orientado a objetos.  think that anemic objects are real objects, and thus completely miss the point of what object-oriented design is all about.
h2. <a name="properties">Properties simulation</a>

If you take a look at Play sample applications, you will often see that classes declare public variables. Now if you’re a Java developer with any experience at all, warning sirens are probably clanging like mad at the sight of a public variable. In Java (as in other object-oriented languages), best practice says to make all fields private and provide accessors and mutators. This is to promote encapsulation, a concept critical to object oriented design.

Java has no truly built-in property definition system. It uses a convention named Java Beans: a property on a Java object is defined by a couple of getXxx/setXxx methods. If the property is read-only there is only a getter.

Although the system works well, it’s very tedious to write. For each property you have to declare a private variable and write two methods. Thus, most of time the getter and setter implementation is always the same:

bc. private String name;
 
public String getName() {
    return name;
}
 
public void setName(String value) {
    name = value;
}

The Model portion of the Play framework automatically generates this pattern while keeping your code clean. Effectively, all public variables become instance properties. The convention is that any **public**, **non-static**, **non-final** field of a class is seen as a property.

For example, when you define a class like this:

bc. public class Product {
 
    public String name;
    public Integer price;
}

The loaded class will be:

bc. public class Product {
 
    public String name;
    public Integer price;
 
    public String getName() {
        return name;
    }
 
    public void setName(String name) {
        this.name = name;
    }
 
    public Integer getPrice() {
        return price;
    }
 
    public void setPrice(Integer price) {
        this.price = price;
    }
}

Then when you want to access a property you can just write:

bc. product.name = "My product";
product.price = 58;

Which is translated at load time to:

bc. product.setName("My product");
product.setPrice(58);

p(note). **Warning!**
 
You can’t directly use getter and setter methods to access properties if you rely on automatic generation. These methods are generated at runtime. So if you reference them in code you write, the compiler won’t find the methods and will generate an error.

Of course you can define the getter and setter methods yourself. If a method exists Play will use the existing accessors.

So to protect the Product class’ price property value, you can write:

bc. public class Product {
 
    public String name;
    public Integer price;
 
    public void setPrice(Integer price) {
        if (price < 0) {
            throw new IllegalArgumentException("Price can’t be negative!");
        }
        this.price = price;
    }
}

Then if you try to set a property to a negative value an exception will be thrown:

bc. product.price = -10: // Oops! IllegalArgumentException

Play will always use the defined getter or setter if it exists. Look at this code:

bc. @Entity
public class Data extends Model {
 
   @Required
   public String value;
   public Integer anotherValue;
 
   public Integer getAnotherValue() {
       if(anotherValue == null) {
           return 0;
       }
       return anotherValue;
   }
 
   public void setAnotherValue(Integer value) {
       if(value == null) {
           this.anotherValue = null;
       } else {
           this.anotherValue = value * 2;
       }
   }
 
   public String toString() {
       return value + " - " + anotherValue;
   }
 
}

From another class, you can try these assertions:

bc. Data data = new Data();
data.anotherValue = null;
assert data.anotherValue == 0;
data.anotherValue = 4
assert data.anotherValue == 8;

Yes it works. And because the enhanced class follows the Java Beans convention, when you use your object with a library that expects a JavaBean it will work perfectly!


h2. <a name="database">Set-up a database to persist your model objects</a>

Most of the time you will need to save the model object data permanently. The most natural way is to save this data into a database. 

During development, you can quickly set up an embedded database either in-memory or save it in a sub-directory within your application using the "db configuration":configuration#db.

The Play distribution includes JDBC drivers for H2 and MySQL in the @$PLAY_HOME/framework/lib/@ directory. If you are using a PostgreSQL or Oracle database, for example, then you should add the JDBC driver library there, or in your application’s @lib/@ directory.

To connect to any JDBC compliant database. Just add the driver library to and define the JDBC properties "db.url":configuration#db.url, "db.driver":configuration#db.driver, "db.user":configuration#db.user and "db.pass":configuration#db.pass:

bc. db.url=jdbc:mysql://localhost/test
db.driver=com.mysql.jdbc.Driver
db.user=root
db.pass=

You can also configure a JPA dialect with "jpa.dialect":configuration#jpa.dialect.

From your code, you can then obtain a @java.sql.Connection@ from the @play.db.DB@ and use it in the standard way.

bc. Connection conn = DB.getConnection();
conn.createStatement().execute("select * from products");

h2. <a name="hibernate">Persist your object model with Hibernate</a>

You can use Hibernate (through JPA) to persist your Java objects in the Database automatically.

When you define JPA entities by adding <code>@javax.persistence.Entity</code> annotations to any Java object, Play will automatically start a JPA entity manager.

bc. @Entity
public class Product {
 
    public String name;
    public Integer price;
}

p(note). **Warning!**
 
A common mistake is to use the Hibernate <code>@Entity</code> annotation instead of the JPA one. Remember that Play uses Hibernate through the JPA API.

You can then obtain the EntityManager from the @play.db.jpa.JPA@ object:

bc. EntityManager em = JPA.em();
em.persist(product);
em.createQuery("from Product where price > 50").getResultList();

Play provides a nice support class to help you to deal with JPA. Just extend @play.db.jpa.Model@.

bc. @Entity
public class Product extends Model {
 
    public String name;
    public Integer price;
}

And then manipulate the @Product@ object using simple methods on the @Product@ instances:

bc. Product.find("price > ?", 50).fetch();
Product product = Product.findById(2L);
product.save();
product.delete();

h2. <a name="stateless">Keep the model stateless</a>

Play is designed to operate in a ‘share nothing’ architecture. The idea is to keep the application completely stateless. By doing this you will allow your application to run on as many server nodes as needed at the same time.

What are the common traps you should avoid to keep the model stateless? **Do not store any object on the Java heap for multiple requests**

h4. When you want to keep data across multiple requests you have several choices:

# If data is small and simple enough, store it into the flash or the session scope. However these scopes are limited to about 4 KB each, and allow only String data.
# Save the data permanently into persistent storage (like a database). For example if you need to create an object with a "wizard" that spans multiple requests:
#* Initialize and persist the object into the database at the first request.
#* Save the newly-created object’s ID into the flash scope.
#* During successive requests, retrieve the object from the database using the object ID, update it, and save it again. 
# Save the data temporarily into a transient storage (such as the Cache). For example if you need to create an object with a "wizard" that spans multiple requests:
#* Initialize the object and save it into the Cache at the first request.
#* Save the newly-created object’s key into the flash scope
#* During successive requests, retrieve the object from the cache (with the correct key), update it, and save it into the cache again. 
#* At the end of the last request in the chain, save the object permanently (into the database for example)

The Cache is not a reliable storage but if you put an object in the cache you should be able to retrieve it. Depending on your requirements, the Cache can be a very good choice and a good replacement for the Java Servlet session.

p(note). **Continuing the discussion**
 
Now we’ll check how to persist the model using %(next)"JPA persistence":jpa%.
